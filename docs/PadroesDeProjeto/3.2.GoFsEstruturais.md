# 3.2. M√≥dulo Padr√µes de Projeto GoFs Estruturais

## 3.2.1. Introdu√ß√£o

Os padr√µes de projeto **Estruturais** s√£o focados em como *classes* e *objetos* podem ser compostos para formar estruturas mais complexas e flex√≠veis dentro de um sistema. O objetivo principal desses padr√µes √© garantir que as rela√ß√µes entre os objetos sejam extens√≠veis, desacopladas e eficientes, permitindo a cria√ß√£o de sistemas mais robustos e f√°ceis de modificar. Eles descrevem formas de organizar as classes e objetos em um software, facilitando a constru√ß√£o de estruturas maiores e mais funcionais <a href="#REF1">[1]</a> <a href="#REF2">[2]</a> <a href="#REF3">[3]</a> <a href="#REF4">[4]</a>.

Esses padr√µes s√£o fundamentais para a cria√ß√£o de interfaces e implementa√ß√µes, especialmente quando se trabalha com heran√ßa, e ajudam a estabelecer uma organiza√ß√£o eficiente das entidades do sistema. Ao organizar as classes e objetos, eles promovem o desacoplamento, permitindo que mudan√ßas em uma parte do sistema n√£o afetem drasticamente outras partes. Al√©m disso, esses padr√µes facilitam a comunica√ß√£o entre as entidades, tornando o c√≥digo mais flex√≠vel, adapt√°vel e mais f√°cil de entender e manter <a href="#REF5">[5]</a>. 

## Participantes

<font size="3"><p style="text-align: center">Tabela 1: Participantes</p></font>

<div align="center">
<table>
  <thead>
    <tr>
      <th>Nome</th>
      <th>Fun√ß√£o</th>
      <th>Data</th>
      <th>Hora</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><a href="https://github.com/caioduart3">Caio Duarte</a></td>
      <td>GoF Estrutural - Composite</td>
      <td>22/10/2025</td>
      <td>20:00</td>
    </tr>
    <tr>
      <td><a href="https://github.com/danielle-soaress">Danielle Soares</a></td>
      <td>GoF Estrutural - Facade</td>
      <td>22/10/2025</td>
      <td>11:00</td>
    </tr>
    <tr>
      <td><a href="https://github.com/EnzoEmir">Enzo Emir</a></td>
      <td>GoF Estrutural - Facade</td>
      <td>22/10/2025</td>
      <td>11:00</td>
    </tr>
    <tr>
      <td><a href="https://github.com/felixlaryssa">Laryssa F√©lix</a></td>
      <td>GoF Estrutural - Composite</td>
      <td>22/10/2025</td>
      <td>20:00</td>
    </tr>
    <tr>
      <td><a href="https://github.com/Leticia-Arisa-K-Higa">Leticia Arisa</a></td>
      <td>GoF Estrutural - Facade</td>
      <td>22/10/2025</td>
      <td>11:00</td>
    </tr>
    <tr>
      <td><a href="https://github.com/MM4k">Marcelo Makoto</a></td>
      <td>GoF Estrutural - Composite</td>
      <td>22/10/2025</td>
      <td>20:00</td>
    </tr>
    <tr>
      <td><a href="https://github.com/dudaa28">Maria Eduarda</a></td>
      <td>GoF Estrutural - Composite</td>
      <td>22/10/2025</td>
      <td>20:00</td>
    </tr>
    <tr>
      <td><a href="https://github.com/RafaelSchadt">Rafael Welz</a></td>
      <td>GoF Estrutural - Composite</td>
      <td>22/10/2025</td>
      <td>20:00</td>
    </tr>
    <tr>
      <td><a href="https://github.com/VictorPontual">Victor Pontual</a></td>
      <td>GoF Estrutural - Facade</td>
      <td>20/10/2025</td>
      <td>11:00</td>
    </tr>
  </tbody>
</table>
</div>

<font size="2"><p style="text-align: center">Fonte: Equipe do Projeto, 2025.</p></font>

## 3.2.2. Metodologia

A pesquisa e o desenvolvimento do estudo dos Padr√µes de Projeto Comportamentais foram conduzidos seguindo uma abordagem pr√°tica e colaborativa, focada na aplica√ß√£o real dos conceitos em um sistema de *software* existente.

### 3.2.2.1. Revis√£o e Sele√ß√£o de Padr√µes
Iniciou-se com a revis√£o do cat√°logo de Padr√µes de Projeto Comportamentais da "Gang of Four" (GoF), conforme introduzido na se√ß√£o anterior. Foram selecionados os padr√µes mais relevantes para resolver problemas de intera√ß√£o e comunica√ß√£o observados no **software interno do jogo**, que est√° hospedado em um reposit√≥rio de c√≥digo separado.

### 3.2.2.2. Aplica√ß√£o e Implementa√ß√£o
Os padr√µes de projeto selecionados (*Facade* e *Composite*) foram implementados diretamente no c√≥digo-fonte do *software* interno do jogo. Esta etapa foi crucial para testar a efic√°cia dos padr√µes na redu√ß√£o do acoplamento, melhoria da legibilidade e aumento da flexibilidade do sistema.

### 3.2.2.3. Modelagem e Documenta√ß√£o UML
Para documentar visualmente a estrutura e a aplica√ß√£o dos padr√µes, o *software* **Draw.io** foi utilizado para a cria√ß√£o de **Diagramas UML (Linguagem de Modelagem Unificada)**. Esses diagramas (principalmente de Classe e/ou Sequ√™ncia) serviram para mapear as novas intera√ß√µes e rela√ß√µes entre os objetos resultantes da aplica√ß√£o dos padr√µes Comportamentais.

### 3.2.2.4. Demonstra√ß√£o e Colabora√ß√£o
Para garantir a transpar√™ncia do processo e documentar a participa√ß√£o de cada membro, as sess√µes de desenvolvimento, discuss√µes t√©cnicas e demonstra√ß√µes de execu√ß√£o do c√≥digo foram **gravadas por meio da plataforma Microsoft Teams**. Essas grava√ß√µes serviram como artefatos de evid√™ncia, demonstrando a aplica√ß√£o pr√°tica dos padr√µes, o fluxo de trabalho colaborativo e a contribui√ß√£o individual dos membros da equipe na solu√ß√£o dos problemas de design.

## **3.2.3. Composite**

O padr√£o **Composite** √© um padr√£o de projeto estrutural que visa **compor objetos em estruturas de √°rvore** para representar hierarquias **"parte-todo"**.

A inten√ß√£o principal √© permitir que os clientes (c√≥digo que utiliza a estrutura) **tratem objetos individuais e composi√ß√µes de objetos de maneira uniforme**.

### 3.2.3.1. Diagrama UML

O GoF Estrutural *Composite* foi aplicado ao projeto, no seguinte c√≥digo:

![diret√≥rio do c√≥digo](../assets/GoFsEstruturais/image.png)

<font size="2"><p style="text-align: center">Fonte: Equipe do Projeto, 2025.</p></font>

???+ note "Aplica√ß√£o do Padr√£o Composite (Gerenciamento de Sprites)"
    O trecho de c√≥digo a seguir, extra√≠do do arquivo principal de gerenciamento de *sprites* (`sprite_groups.py`) demonstra a implementa√ß√£o do Padr√£o Composite atrav√©s da classe `SpriteComposite`.  
    Essa classe unifica a gest√£o de diversos grupos de *sprites* (`caiporas`, `inimigos`, `projeteis`, etc.) permitindo que opera√ß√µes como `update()` e `draw()` sejam executadas de forma transparente em todos os grupos de uma s√≥ vez.

    ```python
    import pygame
    from Template.UIConfigs import *

    class SpriteComposite:
        """Gerenciador unificado de todos os grupos de sprites do jogo."""
        def __init__(self):
            self.caiporas = pygame.sprite.Group()
            self.inimigos = pygame.sprite.Group()
            self.projeteis = pygame.sprite.Group()
            self.guaranas = pygame.sprite.Group()

            self._all_groups = [
                self.projeteis,
                self.caiporas,
                self.inimigos,
                self.guaranas
            ]

        def update(self):
            for group in self._all_groups:
                group.update()

        def draw(self, surface):
            for group in self._all_groups:
                group.draw(surface)

        def reset(self):
            for group in self._all_groups:
                group.empty()

    sprite_manager = SpriteComposite()
    ```

Portanto, assim ficou modelado em UML, o padr√£o Composite no c√≥digo do jogo. Clique aqui para [acessar](https://app.diagrams.net/#G1p7RkwHkF4gsjF1OD6TZ4vaDRCexq4uEc#%7B"pageId"%3A"C5RBs43oDa-KdzZeNtuy"%7D):

[![Ver UML do Composite](../assets/GoFsEstruturais/CompositeEstrutural.drawio.svg)](https://app.diagrams.net/#G1p7RkwHkF4gsjF1OD6TZ4vaDRCexq4uEc#%7B"pageId"%3A"C5RBs43oDa-KdzZeNtuy"%7D)

<font size="2"><p style="text-align: center">Fonte: Caio Duarte, Laryssa F√©lix, Marcelo Matoko, Maria Eduarda, Rafael Schadt, 2025.</p></font>

O diagrama acima ilustra a **arquitetura de classes respons√°vel pelo gerenciamento de sprites** no jogo, evidenciando como o **Padr√£o de Projeto Composite** foi aplicado para unificar e organizar diferentes tipos de entidades (como personagens, inimigos, proj√©teis e defesas) sob uma mesma estrutura de controle.

No topo, encontra-se a classe **`SpriteComposite`**, que atua como o **componente composto principal**. Ela agrega diversos grupos de sprites ‚Äî como `caiporas`, `inimigos`, `projeteis` e `guaranas` ‚Äî, todos representados por inst√¢ncias de `pygame.sprite.Group`. Essa classe possui m√©todos como `update()` e `draw()`, que **propagam as opera√ß√µes** de atualiza√ß√£o e renderiza√ß√£o para todos os grupos internos, mantendo a hierarquia de forma transparente.

Logo abaixo, a classe **`Entity`** funciona como a **classe base abstrata** para todos os objetos que possuem representa√ß√£o visual e comportamento no jogo. Ela define atributos comuns, como:

- `image`: superf√≠cie gr√°fica da entidade.  
- `rect`: posi√ß√£o e √°rea de colis√£o.  
- `health`: quantidade de vida da entidade.  
- `update()`: m√©todo gen√©rico para atualiza√ß√£o, que pode ser sobrescrito pelas subclasses.

As classes derivadas de `Entity` representam os **tipos espec√≠ficos de entidades do jogo**, sendo elas:

- **`Defesa`**: define estruturas defensivas com atributos de custo, estado atual e comportamento de bloqueio.  
- **`Guarana`**: representa a moeda do jogo, possuindo atributos de velocidade, imagem e m√©todo de colis√£o (`collide()`).  
- **`Arrow`**: modela flechas ou proj√©teis inimigos, com propriedades de dano e trajet√≥ria.  
- **`Enemies`**: classe gen√©rica para inimigos, contendo l√≥gica de movimento, estado e ataque.

Al√©m disso, h√° classes especializadas que **herdam dessas entidades principais**:

- **`Caipora`**: herda de `Defesa` e adiciona comportamentos espec√≠ficos, como anima√ß√µes, ataques e controle de tempo de a√ß√£o.  
- **`BichoPapao`**: herda de `Enemies` e especializa os par√¢metros de dano, velocidade e anima√ß√µes de ataque.

Essa organiza√ß√£o reflete o uso do **Composite** aliado √† **heran√ßa hier√°rquica**:

- O `SpriteComposite` **orquestra** todos os grupos de entidades do jogo.  
- Cada entidade, derivada de `Entity`, **atua como um componente individual** dentro dessa estrutura unificada.

Em resumo, o diagrama mostra **uma hierarquia bem definida e extens√≠vel**, em que o Composite (`SpriteComposite`) gerencia m√∫ltiplos objetos (entidades e subclasses) como se fossem um √∫nico conjunto, favorecendo a coes√£o e o baixo acoplamento entre os m√≥dulos do sistema.

### 3.2.3.2. Opni√µes dos Participantes

A elabora√ß√£o desta etapa foi realizada de forma colaborativa em reuni√£o pelo *Discord*, n√£o gravada,  onde os tr√™s membros designados estiveram presentes e participaram ativamente da discuss√£o/elabora√ß√£o.  
O processo da execu√ß√£o do c√≥digo foi feito no *Visual Studio Code* e a elabora√ß√£o da UML foi feita no *Draw.io*, ferramenta que possibilitou a cria√ß√£o e edi√ß√£o simult√¢nea do diagrama, garantindo integra√ß√£o e alinhamento entre os integrantes.  

Ao longo da atividade, cada integrante trouxe ideias e feedbacks que ajudaram a consolidar um resultado alinhado com a vis√£o do grupo como um todo. Esse processo coletivo contribuiu tanto para a consist√™ncia do diagrama quanto para o fortalecimento da colabora√ß√£o na equipe.

<details>
  <summary><strong><a href="https://github.com/caioduart3">Caio Duarte</a></strong></summary>
  <p>No in√≠cio, achei o padr√£o Composite um pouco confuso de entender, mas com a ajuda dos meus colegas consegui compreender melhor como ele funciona e de que forma poderia ser aplicado ao nosso projeto. No final, percebi que √© um padr√£o muito interessante e √∫til para organizar a estrutura do c√≥digo, n√£o s√≥ no nosso projeto, mas em praticamente qualquer outro que exija uma hierarquia bem definida entre objetos.</p>
</details>

<details>
  <summary><strong><a href="https://github.com/felixlaryssa">Laryssa F√©lix</a></strong></summary>
  <p>Assim que comecei a explorar este conte√∫do achei um pouco abstrato, mas ap√≥s ver exemplos pr√°ticos que tudo come√ßou a fazer sentido. Percebi que esse padr√£o √© muito √∫til para organizar as sprites em estruturas hier√°rquicas, o que deixou nosso c√≥digo mais limpo e f√°cil de manter.</p>
</details>

<details>
  <summary><strong><a href="https://github.com/MM4k">Marcelo Matoko</a></strong></summary>
  <p>No come√ßo, eu tive um pouco de dificuldade em entender como o Composite funciona e como implement√°-lo no projeto. Por√©m, ao estudar mais sobre o assunto e pesquisar por exemplos, a implementa√ß√£o do Composite se tornou mais simples e ajudou a estruturar os sprites das entidades de uma forma mais organizada e funcional. Isso ajudou a organizar parte do projeto e deix√°-lo mais leg√≠vel.</p>
</details>

<details>
  <summary><strong><a href="https://github.com/dudaa28">Maria Eduarda Andrade</a></strong></summary>
  <p>Assim como em todo come√ßo, eu me perdi um pouco em como aplicar o Composite dentro da vis√£o do nosso projeto. Depois de algumas discuss√µes e pesquisas com a equipe, percebi que ele seria muito √∫til para organizar a estrutura do c√≥digo e dar mais clareza ao que est√°vamos construindo. No fim, o padr√£o ajudou a tratar partes do jogo como um todo, deixando a arquitetura mais limpa e alinhada aos princ√≠pios do pr√≥prio Composite.</p>
</details>

<details>
  <summary><strong><a href="https://github.com/RafaelSchadt">Rafael Schadt</a></strong></summary>
  <p>De fato, no come√ßo, o padr√£o Composite me pareceu um exagero de abstra√ß√£o. Achei que a complexidade de criar uma interface comum s√≥ para for√ßar o tratamento uniforme de objetos simples e compostos era desnecess√°ria para o nosso caso. Pensei que uma estrutura de classes mais direta j√° resolveria. Contudo, ao longo da implementa√ß√£o e conforme a hierarquia de objetos do projeto foi crescendo, percebi que essa "complica√ß√£o" inicial se tornou a nossa maior aliada. Hoje, vejo que √© um padr√£o essencial para manter a escalabilidade e a clareza do c√≥digo em qualquer projeto que envolva uma estrutura de √°rvore ou composi√ß√£o, provando que a complexidade inicial valeu a pena pela organiza√ß√£o final.</p>
</details>


### 3.2.3.3. V√≠deo Demonstrativo

Foi gravado, na plataforma do Microsoft Teams, uma reuni√£o para a modelagem UML do padr√£o Composite e a execu√ß√£o do c√≥digo al√©m da explica√ß√£o do mesmo. Clique [aqui](https://youtu.be/62f51kDLWNQ?si=3HCpRg2Mn46kOYO0) para acessar.

<div align="center">
    <iframe width="560" height="315" src="https://youtube.com/embed/62f51kDLWNQ?si=3HCpRg2Mn46kOYO0" title="YouTube video player" frameborder="0" allowfullscreen></iframe>
</div>

## **3.2.4. Facade**

O padr√£o Facade (Fachada) √© um padr√£o de projeto estrutural do Gang of Four (GoF) que visa simplificar a intera√ß√£o com sistemas complexos, fornecendo uma interface unificada para um conjunto de classes, bibliotecas ou subsistemas inteiros.

Em vez de o c√≥digo cliente precisar conhecer e interagir diretamente com as partes internas e detalhadas do sistema, ele se comunica apenas com a fachada, que encapsula e coordena as chamadas para os componentes corretos. Assim, o objetivo principal √© esconder a complexidade interna e reduzir o acoplamento entre o cliente e o sistema.

### **3.2.4.1. Estrutura em c√≥digo**

O GoF Estrutural *Facade* foi aplicado ao projeto, no seguinte c√≥digo:
<br>

![!diret√≥rio do c√≥digo](../assets/GoFsEstruturais/facade-code.png)


???+ note "Aplica√ß√£o do Padr√£o Facade (Gerenciamento de Input e Renderiza√ß√£o)"
    Os trechos a seguir, extra√≠dos dos arquivos InputHandler.py e ViewRenderer.py, demonstram a aplica√ß√£o do Padr√£o de Projeto Facade no projeto.
    As classes InputHandler e ViewRenderer encapsulam a complexidade dos sistemas de entrada e renderiza√ß√£o, oferecendo interfaces simplificadas e unificadas para o restante do jogo.
    Com isso, o c√≥digo cliente n√£o precisa lidar diretamente com eventos do Pygame nem com a l√≥gica de transi√ß√£o entre telas, mantendo o baixo acoplamento e a alta coes√£o.

    ```python
    import pygame
    from typing import Callable, Dict, Optional

    class InputHandler:
        """
        Facade respons√°vel por capturar, distribuir e processar eventos de entrada.
        Esconde a complexidade do sistema de input do Pygame.
        """
        _global_handlers: Dict[str, Callable] = {}
        _keys_pressed: Dict[int, bool] = {}
        _mouse_buttons: Dict[int, bool] = {}
        _mouse_pos: tuple = (0, 0)
        _input_enabled = True

        @classmethod
        def inicializar(cls):
            """Inicializa o Facade de Input."""
            cls._global_handlers.clear()
            cls._keys_pressed.clear()
            print("[InputHandler] Facade de Input inicializado")

        @classmethod
        def process_events(cls) -> bool:
            """Interface simplificada para processar todos os eventos."""
            if not cls._input_enabled:
                pygame.event.clear()
                return True

            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    return False
                cls._atualizar_estado(event)
                if cls._processar_handlers_globais(event):
                    continue
                cls._distribuir_evento(event)
            return True

        @classmethod
        def setup_default_shortcuts(cls):
            """Registra atalhos globais padr√£o (ex: ESC para menus e pausas)."""
            def handler_esc(event):
                if event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
                    print("[InputHandler] ESC pressionado ‚Äî alternando telas ou modais")
                    return True
                return False
            cls._global_handlers["esc"] = handler_esc
    ```

    ```python
    import pygame
    from typing import Dict, Optional
    from View.Interfaces import IScreen

    class ViewRenderer:
        """
        Facade respons√°vel por gerenciar telas, transi√ß√µes e renderiza√ß√£o.
        Esconde a complexidade do sistema de telas e recursos gr√°ficos.
        """
        _current_screen: Optional[IScreen] = None
        _current_screen_name: Optional[str] = None
        _all_screens: Dict[str, IScreen] = {}
        FONTE = None

        @classmethod
        def inicializar(cls):
            """Inicializa fontes e prepara o sistema de renderiza√ß√£o."""
            cls.FONTE = pygame.font.SysFont('Arial', 30)
            print("[ViewRenderer] Fontes inicializadas")

        @classmethod
        def add_screen(cls, name: str, screen: IScreen):
            """Adiciona uma nova screen ao sistema."""
            cls._all_screens[name] = screen
            print(f"[ViewRenderer] Screen '{name}' registrada")

        @classmethod
        def transition_to(cls, name: str):
            """Gerencia transi√ß√£o entre screens (fecha a atual e abre a nova)."""
            if cls._current_screen:
                cls._current_screen.close_screen()
            cls._current_screen = cls._all_screens.get(name)
            if cls._current_screen:
                cls._current_screen.open_screen()
                cls._current_screen_name = name
                print(f"[ViewRenderer] Transi√ß√£o para '{name}' conclu√≠da")

        @classmethod
        def render(cls, surface: pygame.Surface):
            """Renderiza a screen e modais ativos."""
            from Core.ScreenManager import ScreenManager
            if cls._current_screen:
                cls._current_screen.draw(surface)
            for modal in ScreenManager._modals:
                modal.draw(surface)
    ```

Com a utiliza√ß√£o dessas fachadas:

- **`InputHandler`**: atua como uma fachada para o subsistema de eventos do Pygame. Ele esconde a complexidade de capturar a fila de eventos, verificar o tipo de cada evento (teclado, mouse), e decidir para qual componente o evento deve ser enviado.

- **`ViewRenderer`**: serve como uma fachada para todo o subsistema de visualiza√ß√£o. Em vez de cada parte do c√≥digo ter que gerenciar diretamente a troca de telas, o carregamento de fontes e a renderiza√ß√£o de m√∫ltiplas camadas , o ViewRenderer oferece uma interface simples.
  
Assim, sem precisar conhecer a complexidade interna dos subsistemas, o c√≥digo cliente pode simplesmente chamar:

```python
InputHandler.process_events()
ViewRenderer.transition_to("menu")
```

### **3.2.4.2. Diagrama UML**

Portanto, assim ficou modelado em UML o padr√£o Facade no c√≥digo do jogo. Clique aqui para [acessar](https://app.diagrams.net/#G1_oBaHXP7-jTN77sSWRbKSxIPQwD_1cUN):

O Diagrama completo abaixo mostra todas as classes e rela√ß√µes do padr√£o, permitindo entender a arquitetura global do Facade no jogo. Como o diagrama ficou extenso, logo a seguir ter√£o imagens com zoom em cada fachada (InputHandler e ViewRenderer).

<br>

[![Ver UML do Composite](../assets/GoFsEstruturais/facade-diagrama-completo.png)](https://app.diagrams.net/#G1_oBaHXP7-jTN77sSWRbKSxIPQwD_1cUN)

<font size="2"><p style="text-align: center">Figura 2: Diagrama UML completo.</p></font>

<br>

![Diagrama da Fachada de InputHandler](../assets/GoFsEstruturais/facade-parte-input.png)

<font size="2"><p style="text-align: center">Figura 3: Diagrama com zoom na fachada InputHandler.</p></font>

<br>

![Diagrama da Fachada de ViewRenderer](../assets/GoFsEstruturais/facade-parte-view.png)

<font size="2"><p style="text-align: center">Figura 4: Diagrama com zoom na fachada ViewRenderer.</p></font>

O diagrama acima ilustra a arquitetura de gerenciamento dos subsistemas centrais do jogo, evidenciando como o **Padr√£o de Projeto Facade** foi aplicado para unificar e simplificar drasticamente a intera√ß√£o com os complexos sistemas de **Entrada** (Input) e **Renderiza√ß√£o** (View).

No topo, encontra-se a classe **`GameMain`**, que atua como o cliente principal e orquestrador da arquitetura. Ela cont√©m o *game loop* e orquestra o fluxo do jogo, mas, em vez de lidar diretamente com a complexidade dos eventos do Pygame ou com o gerenciamento de telas, ela delega essas responsabilidades. `GameMain` possui uma rela√ß√£o de Depend√™ncia com as duas fachadas, pois ela invoca seus m√©todos est√°ticos (`.inicializar()`, `.process_events()`) para controlar o ciclo de vida e a execu√ß√£o delas.

As fachadas s√£o os componentes centrais que definem o padr√£o:

1.  **`InputHandler` (Fachada de Entrada)**: Atua como um ponto de acesso unificado  para todo o subsistema de eventos.
    * **Responsabilidade**: Encapsula a l√≥gica de capturar a fila de eventos brutos do Pygame, process√°-los (`process_events()`), rastrear estados (como `mouse_posicao()`) e classificar eventos.

2.  **`ViewRenderer` (Fachada de Renderiza√ß√£o)**: Serve como o ponto de acesso unificado para todo o subsistema de visualiza√ß√£o.
    * **Responsabilidade**: Encapsula a complexidade de gerenciar qual tela est√° ativa, orquestrar transi√ß√µes (`transition_to()`), comandar a renderiza√ß√£o (`render()`) e gerenciar recursos gr√°ficos compartilhados (como fontes via `get_fonte()`).

Al√©m do `GameMain`, o diagrama detalha outros clientes que dependem dessas fachadas:

* **Clientes de Renderiza√ß√£o**: As classes `MenuScreenRenderer`, `DifficultScreenRenderer`, `LevelSelectionScreenRenderer`, `GameScreenRenderer`, `ConfigModalRenderer` e `PauseModalRenderer` s√£o tamb√©m clientes do padr√£o. Elas dependem da fachada `ViewRenderer` para obter acesso a recursos gr√°ficos centralizados, como fontes (`get_fonte()`), e para executar suas l√≥gicas de desenho.

* **Clientes de Entrada**: Notavelmente, o diagrama mostra que as classes `MenuScreen`, `DifficultScreen`, `LevelSelectionScreen`, `GameScreen`, `ConfigModal` e `PauseModal` s√£o tamb√©m clientes do padr√£o. Elas dependem da fachada `InputHandler` para simplificar o processamento de eventos, usando m√©todos como `classificar_evento()` e `mouse_posicao()` para implementar suas l√≥gicas de intera√ß√£o espec√≠ficas (como cliques em bot√µes).

Essa organiza√ß√£o reflete o uso claro do **Facade** para criar pontos de acesso simplificados:

* O `GameMain` (cliente principal) permanece limpo e focado, interagindo apenas com chamadas de alto n√≠vel como `InputHandler.process_events()` e `ViewRenderer.render()`.

* As fachadas escondem toda a complexidade interna (a fila de eventos do Pygame, a l√≥gica de transi√ß√£o de telas, o gerenciamento de fontes e a distribui√ß√£o de eventos), garantindo que os clientes (`GameMain`, `Screens`, `Renderers`) permane√ßam desacoplados dos detalhes de implementa√ß√£o desses subsistemas.

Em resumo, o diagrama mostra uma arquitetura onde as fachadas atuam como "porteiros" simplificados para os sistemas de entrada e visualiza√ß√£o. Isso permite que tanto o `GameMain` quanto as telas e modais operem em um n√≠vel de abstra√ß√£o muito mais alto, facilitando a manuten√ß√£o e a extens√£o do c√≥digo.

### **3.2.4.2. V√≠deo de Execu√ß√£o**

Foi gravado, na plataforma do Microsoft Teams, uma reuni√£o para a modelagem UML do padr√£o Facade. 

Clique [aqui](https://www.youtube.com/watch?v=Jyx_49t3pEk) para acessar a parte 1 e [aqui](https://www.youtube.com/watch?v=5SWWsrv-F6s) para acessar a parte 2.

<div align="center">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/Jyx_49t3pEk?si=woRWql6HQ0Xk027U" 
    title="YouTube video player" frameborder="0" 
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" 
    referrerpolicy="strict-origin-when-cross-origin" allowfullscreen>
  </iframe>
</div>


<font size="2"><p style="text-align: center">V√≠deo parte 1: Execu√ß√£o do diagrama UML.</p></font>

<br>

<div align="center">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/5SWWsrv-F6s?si=Ul6io50oegeteZT0" 
    title="YouTube video player" frameborder="0" 
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" 
    referrerpolicy="strict-origin-when-cross-origin" allowfullscreen>
  </iframe>
</div>

<font size="2"><p style="text-align: center">V√≠deo parte 2: Execu√ß√£o do diagrama UML e explica√ß√£o ao final</p></font>

### **3.2.4.3. Opini√µes dos Participantes**

<details>
  <summary><strong><a href="https://github.com/danielle-soaress">Danielle Soares</a></strong></summary>
  <p>Minha experi√™ncia implementando o padr√£o Facade foi bastante desafiadora, especialmente devido √† complexidade do diagrama UML, que envolvia muitas classes com diversos m√©todos e atributos. Inicialmente, compreender o funcionamento do Facade e implementar a base das interfaces foi relativamente tranquilo. Entretanto, adaptar o c√≥digo j√° existente a uma arquitetura mais formal exigiu aten√ß√£o detalhada, pois foi necess√°rio analisar cuidadosamente as conex√µes entre as classes e identificar formas de otimizar a estrutura e o fluxo do sistema.</p>
</details>

<details>
  <summary><strong><a href="https://github.com/EnzoEmir">Enzo Emir</a></strong></summary>
  <p>[Opini√£o sobre o padr√£o Facade]</p>
</details>

<details>
  <summary><strong><a href="https://github.com/Leticia-Arisa-K-Higa">Leticia Arisa</a></strong></summary>
  <p>Achei muito interessante estudar sobre o Facade, j√° que ele ajuda a deixar o c√≥digo organizado e simplifica os sistemas complexos. Depois de estudar mais sobre o Facade, percebi que ele √© uma excelente estrat√©gia para criar uma interface √∫nica e mais f√°cil de usar.</p>
</details>

<details>
  <summary><strong><a href="https://github.com/VictorPontual">Victor Pontual</a></strong></summary>
  <p>Foi interessante aprender sobre o padr√£o Facade de forma oficial, pois percebi que eu j√° implementava conceitos similares de maneira casual sem conhecer a teoria formal por tr√°s. No meu c√≥digo, eu costumava criar o que chamava de "hub de requisi√ß√µes" - classes centralizadoras que concentravam opera√ß√µes relacionadas para evitar repeti√ß√£o de c√≥digo e facilitar manuten√ß√£o. Por exemplo, ao inv√©s de espalhar chamadas diretas a APIs ou bibliotecas por todo o c√≥digo, eu criava um ponto √∫nico que encapsulava essa complexidade.
</p>
</details>

## 3.2.6 Refer√™ncias Bibliogr√°ficas

> <a id="REF1">1.</a> GAMMA, Erich et al. **Padr√µes de Projeto: Solu√ß√µes Reutiliz√°veis de Software Orientado a Objetos**. Tradu√ß√£o de C. F. Lucena e F. S. C. da Silva. Porto Alegre: Bookman, 2007. (T√≠tulo original: *Design Patterns: Elements of Reusable Object-Oriented Software*).

> <a id="REF2">2.</a> DEV MEDIA. Padr√£o de Projeto Facade em Java. DevMedia. Dispon√≠vel em: https://www.devmedia.com.br/padrao-de-projeto-facade-em-java/26476. Acesso em: 23 out. 2025.

> <a id="REF3">3.</a> REFACTORING.GURU. Facade. Refactoring.Guru. Dispon√≠vel em: https://refactoring.guru/pt-br/design-patterns/facade. Acesso em: 23 out. 2025.

> <a id="REF1">4.</a> BLOG GRAN CURSOS ONLINE. Padr√µes de Projetos GOF: Padr√µes Estruturais. Dispon√≠vel em: <https://blog.grancursosonline.com.br/padroes-de-projetos-gof-padroes-estruturais/>. Acesso em: 23 out. 2025.

> <a id="REF2">5.</a> REFACTORING GURU. Padr√µes Estruturais. Dispon√≠vel em: <https://refactoring.guru/pt-br/design-patterns/structural-patterns>. Acesso em: 23 out. 2025.

> <a id="REF3">6.</a> MILENE. Arquitetura e Desenho de Software - Aula GoFs Estruturais. Profa. Milene. Dispon√≠vel em: <https://aprender3.unb.br/pluginfile.php/3178397/mod_page/content/1/Arquitetura%20e%20Desenho%20de%20Software%20-%20Aula%20GoFs%20Estruturais%20-%20Profa.%20Milene.pdf>. Acesso em: 23 out. 2025.

> <a id="REF4">7.</a> FIGUEIREDO, Roberto Ten√≥rio. *Disserta√ß√£o: Arquitetura e Padr√µes de Projeto em Sistemas de Software* (Disserta√ß√£o de Mestrado). Universidade Federal de Pernambuco, 2006. Dispon√≠vel em: <https://repositorio.ufpe.br/bitstream/123456789/11981/1/DISSERTA%c3%87%c3%83O%20Roberto%20Tenorio%20Figueiredo.pdf>. Acesso em: 23 out. 2025.


## Hist√≥rico de Vers√µes üìÖ

| Vers√£o | Data | Descri√ß√£o | Autor(es) | Revisor(es) |
| :--: | :--: | :--: | :--: | :--: |
| `0.1` | 22/10/2025 | Adicionando Documenta√ß√£o GoF Estrutural | [Maria Eduarda Andrade](https://github.com/dudaa28), [Rafael Welz](https://github.com/RafaelSchadt) | [Caio Duarte](https://github.com/caioduart3) |
| `0.2` | 24/10/2025 | Adicionando Documenta√ß√£o do GoF Facade | [Danielle Soares](https://github.com/danielle-soaress), [Enzo Emir](https://github.com/EnzoEmir), [Leticia Arisa](https://github.com/Leticia-Arisa-K-Higa), [Victor Pontual](https://github.com/VictorPontual) | - |
| `0.3` | 24/10/2025 | Adi√ß√£o da se√ß√£o de opini√µes dos participantes do Facade e opini√£o pessoal | [Victor Pontual](https://github.com/VictorPontual) | [Danielle Soares](https://github.com/danielle-soaress), [Enzo Emir](https://github.com/EnzoEmir), [Leticia Arisa](https://github.com/Leticia-Arisa-K-Higa), [Victor Pontual](https://github.com/VictorPontual) |
| `0.4` | 24/10/2025 | V√≠deo de execu√ß√£o (Facade) | [Danielle Soares](https://github.com/danielle-soaress), [Enzo Emir](https://github.com/EnzoEmir), [Leticia Arisa](https://github.com/Leticia-Arisa-K-Higa), [Victor Pontual](https://github.com/VictorPontual) | - |
