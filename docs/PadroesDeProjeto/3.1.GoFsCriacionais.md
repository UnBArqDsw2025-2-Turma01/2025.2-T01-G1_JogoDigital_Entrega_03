# 3.1. M√≥dulo Padr√µes de Projeto GoFs Criacionais

## 3.1.1. Introdu√ß√£o

Os **Padr√µes de Projeto Criacionais**, parte do cat√°logo da "Gang of Four" (GoF) <a href="#REF1">[1]</a>, representam solu√ß√µes consagradas para problemas recorrentes relacionados √† **cria√ß√£o de objetos** em _software_ orientado a objetos. Diferentemente dos padr√µes Estruturais e Comportamentais, que lidam com a composi√ß√£o de classes e a comunica√ß√£o entre objetos, os padr√µes Criacionais focam em **como instanciar objetos de maneira flex√≠vel, independente e reutiliz√°vel**.

Esses padr√µes s√£o essenciais para controlar a complexidade associada √† cria√ß√£o de objetos, permitindo **encapsular a l√≥gica de constru√ß√£o**, reduzir depend√™ncias diretas e tornar o c√≥digo mais **adapt√°vel a mudan√ßas**. Eles oferecem formas padronizadas de criar inst√¢ncias sem acoplar o c√≥digo a classes concretas, aumentando a **coes√£o, a reutiliza√ß√£o e a testabilidade** do sistema.

## 3.1.2. Participantes

<font size="3"><p style="text-align: center">Tabela 1: Participantes</p></font>

<div align="center">
<table>
  <thead>
    <tr>
      <th>Nome</th>
      <th>Fun√ß√£o</th>
      <th>Data</th>
      <th>Hora</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><a href="https://github.com/caioduart3">Caio Duarte</a></td>
      <td>GoF Criacional - Singleton</td>
      <td>23/10/2025</td>
      <td>20:30</td>
    </tr>
        <tr>
      <td><a href="https://github.com/danielle-soaress">Danielle Soares</a></td>
      <td>GoF Criacional - Prototype</td>
      <td>24/10/2025</td>
      <td>00:00</td>
    </tr>
    <tr>
      <td><a href="https://github.com/EnzoEmir">Enzo Emir</a></td>
      <td>GoF Criacional - Prototype</td>
      <td>24/10/2025</td>
      <td>00:00</td>
    </tr>
    <tr>
      <td><a href="https://github.com/felixlaryssa">Laryssa F√©lix</a></td>
      <td>GoF Criacional - Singleton</td>
      <td>23/10/2025</td>
      <td>20:30</td>
    </tr>
        <tr>
      <td><a href="https://github.com/Leticia-Arisa-K-Higa">Leticia Arisa</a></td>
      <td>GoF Criacional - Prototype</td>
      <td>24/10/2025</td>
      <td>00:00</td>
    </tr>
        <tr>
      <td><a href="https://github.com/MM4k">Marcelo Makoto</a></td>
      <td>GoF Criacional - Prototype</td>
      <td>24/10/2025</td>
      <td>00:00</td>
    </tr>
        <tr>
      <td><a href="https://github.com/dudaa28">Maria Eduarda</a></td>
      <td>GoF Criacional - Prototype</td>
      <td>24/10/2025</td>
      <td>00:00</td>
    </tr>
    <tr>
      <td><a href="https://github.com/rafaelschadt">Rafael Schadt</a></td>
      <td>GoF Criacional - Singleton</td>
      <td>23/10/2025</td>
      <td>20:30</td>
    </tr>
    <tr>
      <td><a href="https://github.com/VictorPontual">Victor Pontual</a></td>
      <td>GoF Criacional - Singleton</td>
      <td>23/10/2025</td>
      <td>20:30</td>
    </tr>
  </tbody>
</table>
</div>

<font size="2"><p style="text-align: center">Fonte: Equipe do Projeto, 2025.</p></font>

## 3.1.3. Metodologia

A pesquisa e desenvolvimento do estudo dos Padr√µes de Projeto Criacionais foram conduzidos seguindo uma abordagem pr√°tica e colaborativa, com foco na **cria√ß√£o eficiente e flex√≠vel de objetos** dentro do sistema de _software_ do jogo.

### 3.1.3.1. Revis√£o e Sele√ß√£o de Padr√µes

Foi realizada uma revis√£o do cat√°logo de Padr√µes de Projeto Criacionais da GoF, selecionando os padr√µes mais relevantes para **controlar a cria√ß√£o de inst√¢ncias de entidades do jogo**, garantindo que o c√≥digo ficasse mais modular e f√°cil de estender.

### 3.1.3.2. Aplica√ß√£o e Implementa√ß√£o

O padr√£o selecionado (_Singleton_) foi implementado no c√≥digo-fonte do jogo. Essa etapa visou **reduzir acoplamento direto √†s classes concretas** e fornecer um mecanismo centralizado de gerenciamento de recursos.

### 3.1.3.3. Modelagem e Documenta√ß√£o UML

Para documentar visualmente a aplica√ß√£o dos padr√µes, utilizou-se o **Draw.io** para criar **Diagramas de Classes**.

### 3.1.3.4. Demonstra√ß√£o e Colabora√ß√£o

Sess√µes de desenvolvimento e explica√ß√£o do c√≥digo foram **registradas via Microsoft Teams**, documentando o processo de aplica√ß√£o dos padr√µes e o fluxo colaborativo da equipe.

<div style="text-align: center;">
<iframe width="560" height="315" src="https://www.youtube.com/embed/RtJ-M3CTaQI?si=GBrL8RPyPvW3aRfs" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</div>

<font size="2"><p style="text-align: center">V√≠deo 1: Sess√£o de desenvolvimento e explica√ß√£o do padr√£o Singleton.</p></font>

<font size="2"><p style="text-align: center">Fonte: Equipe do Projeto, 2025.</p></font>

## 3.1.4. Singleton

O padr√£o **Singleton** garante que uma classe tenha **uma √∫nica inst√¢ncia** e fornece um ponto global de acesso a ela. No projeto, foi usado para gerenciar recursos globais, como os assets do jogo, garantindo que sejam carregados uma √∫nica vez e compartilhados por todo o sistema.

### 3.1.4.1. Diagrama UML

O Singleton foi aplicado no gerenciamento de inst√¢ncias dos Assets:

  ![Diagrama da Singleton](../assets/GoFsCriacionais/Singleton.drawio.svg)

<font size="2"><p style="text-align: center">Figura 1: Diagrama de Classes do padr√£o Singleton aplicado ao AssetProvider.</p></font>

<font size="2"><p style="text-align: center">Fonte: Equipe do Projeto, 2025.</p></font>

O diagrama UML ilustra como a classe `AssetProvider` implementa o padr√£o Singleton, centralizando o gerenciamento de todos os assets do jogo (imagens, fontes, sprites) e garantindo que esses recursos sejam carregados apenas uma vez durante a execu√ß√£o do programa. A classe utiliza m√©todos est√°ticos (`@classmethod`) para controlar o acesso aos recursos e prevenir m√∫ltiplas instancia√ß√µes atrav√©s do m√©todo `__init__` que lan√ßa uma exce√ß√£o.

### 3.1.4.2. Implementa√ß√£o

<details>
  <summary><strong>C√≥digo de Implementa√ß√£o do Padr√£o Singleton</strong></summary>

```python
import pygame
import os
from Template.UIConfigs import *

class AssetProvider:
"""
Singleton para gerenciamento centralizado de assets do jogo.
"""
ASSETS = {}
\_loaded = False

    def __init__(self):
        """Impede instancia√ß√£o - AssetProvider deve ser usado apenas como classe est√°tica."""
        raise TypeError(
            "AssetProvider n√£o deve ser instanciado. "
            "Use AssetProvider.carregar_assets() e AssetProvider.get(key) diretamente."
        )

    @classmethod
    def carregar_assets(cls):
        """Carrega e escala todos os assets do jogo."""
        if cls._loaded:
            print("[AssetProvider] Assets j√° carregados anteriormente, pulando recarregamento.")
            return

        base_dir = os.path.dirname(os.path.abspath(__file__))
        try:
            # FONTE
            cls.ASSETS['font_press_start_2P'] = pygame.font.Font(os.path.join(base_dir, 'font', 'PressStart2P-Regular.ttf'), 24)

            # MAP TILES
            cls.ASSETS['grass_claro'] = pygame.transform.scale(
                pygame.image.load(os.path.join(base_dir, 'maps', 'map1', 'titleset', 'grass1.png')).convert_alpha(),
                (TAMANHO_QUADRADO, TAMANHO_QUADRADO)
            )
            cls.ASSETS['grass_escuro'] = pygame.transform.scale(
                pygame.image.load(os.path.join(base_dir, 'maps', 'map1', 'titleset', 'grass2.png')).convert_alpha(),
                (TAMANHO_QUADRADO, TAMANHO_QUADRADO)
            )

            #SCOREBOARD
            cls.ASSETS['scoreboard'] = pygame.transform.scale(
                pygame.image.load(os.path.join(base_dir, 'maps', 'map1', 'object', 'map_scoreboard1.png')).convert_alpha(),
                (TAMANHO_QUADRADO*5, TAMANHO_QUADRADO*1.5)
            )

            cls.ASSETS['scoreboard_slot'] = pygame.transform.scale(
                pygame.image.load(os.path.join(base_dir, 'maps', 'map1', 'object', 'player_block01.png')).convert_alpha(),
                (TAMANHO_QUADRADO/1.8, TAMANHO_QUADRADO/1.6)
            )

            # CAIPORA
            cls.ASSETS['caipora_attack'] = [
                pygame.transform.scale(
                    pygame.image.load(os.path.join(base_dir, 'characters', 'defense', 'caipora', f'caipora_attack{i}.png')).convert_alpha(),
                    (TAMANHO_CAIPORA, TAMANHO_CAIPORA)
                )
                for i in range(1, 3)
            ]

            cls.ASSETS['caipora_projectile'] = pygame.transform.scale(
                pygame.image.load(os.path.join(base_dir, 'characters', 'defense', 'caipora', 'caipora_arrow.png')).convert_alpha(),
                (50, 20)
            )

            # BICHO PAP√ÉO
            bp_walk = [
                pygame.image.load(os.path.join(base_dir, 'characters', 'enemies', 'bicho-papao', f'bp_walk{i}.png')).convert_alpha()
                for i in range(1, 5)
            ]
            cls.ASSETS['bp_walk'] = [
                pygame.transform.scale(pygame.transform.flip(img, True, False), (TAMANHO_BP, TAMANHO_BP))
                for img in bp_walk
            ]

            bp_attack = [
                pygame.image.load(os.path.join(base_dir, 'characters', 'enemies', 'bicho-papao', f'bp_attack{i}.png')).convert_alpha()
                for i in range(1, 3)
            ]
            cls.ASSETS['bp_attack'] = [
                pygame.transform.scale(pygame.transform.flip(img, True, False), (TAMANHO_BP, TAMANHO_BP))
                for img in bp_attack
            ]

            # GUARAN√Å (moeda) - carregar com o mesmo padr√£o dos outros assets
            cls.ASSETS['guarana_coin'] = pygame.transform.scale(
                pygame.image.load(os.path.join(base_dir, 'maps', 'map1', 'object', 'guarana_coin.png')).convert_alpha(),
                (40, 40)
            )

            # MENU PAUSA
            cls.ASSETS.update({
                # Fundo do menu pausa
                'menu_pausa': pygame.image.load(
                    os.path.join(base_dir, 'menu_pause', 'menu_pausa.png')
                ).convert_alpha(),

                # Bot√£o M√öSICA
                'btn_musica': pygame.transform.scale(
                    pygame.image.load(os.path.join(base_dir, 'menu_pause', 'botao_musica.png')).convert_alpha(),
                    (200, 60)  # Largura, altura
                ),
                'btn_musica_hover': pygame.transform.scale(
                    pygame.image.load(os.path.join(base_dir, 'menu_pause', 'botao_musica_click.png')).convert_alpha(),
                    (200, 60)
                ),

                # Bot√£o EFEITO SONORO
                'btn_efeito': pygame.transform.scale(
                    pygame.image.load(os.path.join(base_dir, 'menu_pause', 'botao_efeitoSonoro.png')).convert_alpha(),
                    (200, 60)
                ),
                'btn_efeito_hover': pygame.transform.scale(
                    pygame.image.load(os.path.join(base_dir, 'menu_pause', 'botao_efeitoSonoro_click.png')).convert_alpha(),
                    (200, 60)
                ),

                # Bot√£o TUTORIAL
                'btn_tutorial': pygame.transform.scale(
                    pygame.image.load(os.path.join(base_dir, 'menu_pause', 'botao_tutorial.png')).convert_alpha(),
                    (200, 60)
                ),
                'btn_tutorial_hover': pygame.transform.scale(
                    pygame.image.load(os.path.join(base_dir, 'menu_pause', 'botao_tutorial_click.png')).convert_alpha(),
                    (200, 60)
                ),

                # Bot√£o Sair da Partida
                'btn_sair': pygame.transform.scale(
                    pygame.image.load(os.path.join(base_dir, 'menu_pause', 'botao_sair_partida.png')).convert_alpha(),
                    (200, 60)
                ),
                'btn_sair_hover': pygame.transform.scale(
                    pygame.image.load(os.path.join(base_dir, 'menu_pause', 'botao_sair_partida_click.png')).convert_alpha(),
                    (200, 60)
                ),

                # Icone Som Normal
                'icon_som': pygame.transform.scale(
                    pygame.image.load(os.path.join(base_dir, 'menu_pause', 'icone_som_normal.png')).convert_alpha(),
                    (40, 40)
                ),
                'icon_som_hover': pygame.transform.scale(
                    pygame.image.load(os.path.join(base_dir, 'menu_pause', 'icone_som_click.png')).convert_alpha(),
                    (40, 40)
                ),

                # Icone Som Mudo
                'icon_mute': pygame.transform.scale(
                    pygame.image.load(os.path.join(base_dir, 'menu_pause', 'icone_som_mute.png')).convert_alpha(),
                    (40, 40)
                ),

                # Barra de volume
                'barra_volume_mute': pygame.transform.scale(
                    pygame.image.load(os.path.join(base_dir, 'menu_pause', 'barra_0.png')).convert_alpha(),
                    (150, 20)
                ),
                'barra_volume_mute_houver': pygame.transform.scale(
                    pygame.image.load(os.path.join(base_dir, 'menu_pause', 'barra_0_click.png')).convert_alpha(),
                    (150, 20)
                ),
                'barra_volume_25': pygame.transform.scale(
                    pygame.image.load(os.path.join(base_dir, 'menu_pause', 'barra_25.png')).convert_alpha(),
                    (150, 20)
                ),
                'barra_volume_25_houver': pygame.transform.scale(
                    pygame.image.load(os.path.join(base_dir, 'menu_pause', 'barra_25_click.png')).convert_alpha(),
                    (150, 20)
                ),
                'barra_volume_50': pygame.transform.scale(
                    pygame.image.load(os.path.join(base_dir, 'menu_pause', 'barra_50.png')).convert_alpha(),
                    (150, 20)
                ),
                'barra_volume_50_houver': pygame.transform.scale(
                    pygame.image.load(os.path.join(base_dir, 'menu_pause', 'barra_50_click.png')).convert_alpha(),
                    (150, 20)
                ),
                'barra_volume_75': pygame.transform.scale(
                    pygame.image.load(os.path.join(base_dir, 'menu_pause', 'barra_75.png')).convert_alpha(),
                    (150, 20)
                ),
                'barra_volume_75_houver': pygame.transform.scale(
                    pygame.image.load(os.path.join(base_dir, 'menu_pause', 'barra_75_click.png')).convert_alpha(),
                    (150, 20)
                ),
                'barra_volume_100': pygame.transform.scale(
                    pygame.image.load(os.path.join(base_dir, 'menu_pause', 'barra_100.png')).convert_alpha(),
                    (150, 20)
                ),
                'barra_volume_100_houver': pygame.transform.scale(
                    pygame.image.load(os.path.join(base_dir, 'menu_pause', 'barra_100_click.png')).convert_alpha(),
                    (150, 20)
                ),

                # MENU CONFIGURA√á√ïES
                'menu_config': pygame.image.load(
                    os.path.join(base_dir, 'menu_config', 'menu_config.png')
                ).convert_alpha(),
                'btn_voltar': pygame.transform.scale(
                    pygame.image.load(os.path.join(base_dir, 'menu_config', 'botao_voltar.png')).convert_alpha(),
                    (200, 60)
                ),
                'btn_voltar_hover': pygame.transform.scale(
                    pygame.image.load(os.path.join(base_dir, 'menu_config', 'botao_voltar_click.png')).convert_alpha(),
                    (200, 60)
                ),
                'btn_salvar': pygame.transform.scale(
                    pygame.image.load(os.path.join(base_dir, 'menu_config', 'botao_salvar.png')).convert_alpha(),
                    (200, 60)
                ),
                'btn_salvar_hover': pygame.transform.scale(
                    pygame.image.load(os.path.join(base_dir, 'menu_config', 'botao_salvar_click.png')).convert_alpha(),
                    (200, 60)
                ),

                # MENU PRINCIPAL
                'menu_principal': pygame.image.load(
                    os.path.join(base_dir, 'menu', 'menu_screen', 'main_screen.png')
                ).convert_alpha(),

                # Bot√µes do Menu Principal
                'menu_btn_jogar': pygame.image.load(
                    os.path.join(base_dir, 'menu', 'menu_screen', 'main_screen_button3.png')
                ).convert_alpha(),
                'menu_btn_jogar_hover': pygame.image.load(
                    os.path.join(base_dir, 'menu', 'menu_screen', 'main_screen_button_click1.png')
                ).convert_alpha(),

                'menu_btn_loja': pygame.image.load(
                    os.path.join(base_dir, 'menu', 'menu_screen', 'main_screen_button2.png')
                ).convert_alpha(),
                'menu_btn_loja_hover': pygame.image.load(
                    os.path.join(base_dir, 'menu', 'menu_screen', 'main_screen_button_click2.png')
                ).convert_alpha(),

                'menu_btn_creditos': pygame.image.load(
                    os.path.join(base_dir, 'menu', 'menu_screen', 'main_screen_button1.png')
                ).convert_alpha(),
                'menu_btn_creditos_hover': pygame.image.load(
                    os.path.join(base_dir, 'menu', 'menu_screen', 'main_screen_button_click3.png')
                ).convert_alpha(),

                'menu_btn_config': pygame.image.load(
                    os.path.join(base_dir, 'menu', 'menu_screen', 'botao_config.png')
                ).convert_alpha(),
                'menu_btn_config_hover': pygame.image.load(
                    os.path.join(base_dir, 'menu', 'menu_screen', 'botao_config_click.png')
                ).convert_alpha(),
                })

            cls._loaded = True
            print("[AssetProvider] Assets carregados com sucesso.")

        except pygame.error as e:
            print(f"[AssetProvider] ERRO CR√çTICO ao carregar assets: {e}")
            pygame.quit()
            exit()

    @classmethod
    def is_loaded(cls) -> bool:
        """Verifica se os assets j√° foram carregados."""
        return cls._loaded

    @classmethod
    def reload(cls):
        """For√ßa recarregamento de todos os assets (use com cautela)."""
        cls._loaded = False
        cls.ASSETS.clear()
        cls.carregar_assets()

    @classmethod
    def get(cls, key):
        """M√©todo helper para acessar um asset."""
        return cls.ASSETS.get(key)
```

</details>

### 3.1.4.3. Opini√µes dos Participantes

<details>
  <summary><strong><a href="https://github.com/caioduart3">Caio Duarte</a></strong></summary>
  <p>Achei um padr√£o simples, √∫til para muitos projetos e contextos e f√°cil de implementar. Acredito que ele se encaixou perfeitamente com o nosso contexto de assets.</p>
</details>

<details>
  <summary><strong><a href="https://github.com/felixlaryssa">Laryssa F√©lix</a></strong></summary>
  <p>  Percebi que o padr√£o Singleton √© muito √∫til em situa√ß√µes em que precisamos garantir que apenas uma inst√¢ncia de uma classe exista em todo o sistema, como no caso de gerenciamento de configura√ß√µes, logs ou assets de um jogo. Ele traz praticidade e evita desperd√≠cio de recursos, j√° que centraliza o acesso a um √∫nico objeto. Por√©m, considero importante us√°-lo com cuidado se for aplicado de forma excessiva, pode acabar dificultando testes e aumentar o acoplamento do c√≥digo. Por isso, acredito que o Singleton deve ser usado apenas quando realmente faz sentido garantir uma √∫nica inst√¢ncia, como no caso de provedores de recursos ou conex√µes¬†globais.</p>
</details>

<details>
  <summary><strong><a href="https://github.com/rafaelSchadt">Rafael Welz Schadt</a></strong></summary>
  <p>Achei o Singleton simples, por√©m muito √∫til. √â aplic√°vel a quase todo o contexto do projeto, e ajuda muito em projetos de pequeno porte.</p>
</details>

<details>
  <summary><strong><a href="https://github.com/VictorPontual">Victor Pontual Guedes Nobrega</a></strong></summary>
  <p>Gostei do padr√£o Singleton porque separa a l√≥gica de cria√ß√£o da l√≥gica de uso, deixando o c√≥digo mais limpo e organizado. No contexto do jogo, ele foi essencial para garantir que os assets sejam carregados uma √∫nica vez e compartilhados por todo o sistema, evitando duplica√ß√£o de mem√≥ria e facilitando o acesso global aos recursos de forma segura e intuitiva atrav√©s dos m√©todos de classe.</p>
</details>

## 3.1.5. Prototype

O padr√£o Prototype √© um padr√£o de projeto criacional que tem como objetivo criar novos objetos a partir da c√≥pia (clone) de inst√¢ncias existentes, em vez de criar novos objetos do zero.

A inten√ß√£o principal √© evitar o custo de criar objetos complexos diretamente e fornecer um mecanismo flex√≠vel de duplica√ß√£o, permitindo que o sistema copie objetos existentes (incluindo suas configura√ß√µes internas) sem depender de suas classes concretas.

### 3.1.5.1. Diagrama UML

O GoF Criacional Prototype foi aplicado ao projeto, no seguinte c√≥digo:

![Diagrama UML Prototype](../assets/GoFsCriacionais/codigo_prototype.png)


???+ note "Aplica√ß√£o do Padr√£o Prototype (Sistema de Cria√ß√£o de Inimigos)"
    O trecho de c√≥digo a seguir, extra√≠do do arquivo principal de gerenciamento de prot√≥tipos de inimigos (`EnemyPrototype.py`) demonstra a implementa√ß√£o do Padr√£o Prototype atrav√©s das classes `IEnemyPrototype`, `EnemyPrototypeRegistry` e `BichoPapaoPrototype`.
    
    Essa implementa√ß√£o permite criar novas inst√¢ncias de inimigos atrav√©s da clonagem de prot√≥tipos pr√©-configurados, ao inv√©s de instanciar diretamente as classes, proporcionando flexibilidade na cria√ß√£o e configura√ß√£o de diferentes tipos de inimigos.

    ```python
    from abc import ABC, abstractmethod
    from typing import Dict, Optional

    class IEnemyPrototype(ABC):
        """Interface Prototype seguindo o padr√£o GOF"""
        
        @abstractmethod
        def clone(self):
            """Clona o prototype atual retornando uma nova inst√¢ncia"""
            pass

    class EnemyPrototypeRegistry:
        """Registry que mant√©m inst√¢ncias dos prototypes para clonagem"""
        
        _prototypes: Dict[str, IEnemyPrototype] = {}
        
        @classmethod
        def register(cls, enemy_type: str, prototype: IEnemyPrototype):
            """Registra um prototype no registry"""
            cls._prototypes[enemy_type] = prototype
        
        @classmethod
        def create(cls, enemy_type: str, grid_x: int, grid_y: int, **kwargs):
            """Cria uma nova inst√¢ncia clonando o prototype registrado"""
            if enemy_type in cls._prototypes:
                # Clona o prototype seguindo padr√£o GOF
                cloned_prototype = cls._prototypes[enemy_type].clone()
                
                # Configura atributos espec√≠ficos se fornecidos
                if kwargs:
                    cloned_prototype.configure(**kwargs)
                
                # Cria a inst√¢ncia real do inimigo
                if hasattr(cloned_prototype, 'create_enemy'):
                    return cloned_prototype.create_enemy(grid_x, grid_y)
                
            return None

    class EnemyFactory:
        """Factory que utiliza o registry para criar inimigos via prot√≥tipos"""
        
        @classmethod
        def create_enemy(cls, enemy_type: str, grid_x: int, grid_y: int, **kwargs):
            return EnemyPrototypeRegistry.create(enemy_type, grid_x, grid_y, **kwargs)
        
        @classmethod
        def create_random_enemy(cls, grid_x: int, grid_y: int):
            import random
            types = EnemyPrototypeRegistry.get_types()
            if types:
                enemy_type = random.choice(types)
                return cls.create_enemy(enemy_type, grid_x, grid_y)
            return None
    ```

???+ note "Implementa√ß√£o do Prototype Concreto (BichoPapao)"
    A classe `BichoPapaoPrototype` implementa a interface `IEnemyPrototype` e demonstra como o padr√£o Prototype funciona na pr√°tica. Ela mant√©m os atributos configur√°veis do inimigo e permite clonagem com diferentes configura√ß√µes.

    ```python
    class BichoPapaoPrototype(IEnemyPrototype):
        """Concrete Prototype seguindo o padr√£o GOF"""
        
        def __init__(self, prototype=None):
            """Constructor que pode receber outro prototype para copiar"""
            if prototype is not None:
                # Copia campos do prototype existente
                self.health = prototype.health
                self.speed = prototype.speed
                self.damage = prototype.damage
                self.scare_range = prototype.scare_range
                self.scare_duration = prototype.scare_duration
                self.scare_cooldown = prototype.scare_cooldown
            else:
                # Valores padr√£o
                self.health = 400
                self.speed = 6
                self.damage = 30
                self.scare_range = 100
                self.scare_duration = 3000
                self.scare_cooldown = 8000
        
        def clone(self):
            """Implementa√ß√£o do clone() seguindo padr√£o GOF"""
            return BichoPapaoPrototype(self)
        
        def create_enemy(self, grid_x: int, grid_y: int):
            """Cria a inst√¢ncia real do BichoPapao com os atributos do prototype"""
            enemy = BichoPapao(grid_x, grid_y)
            
            # Aplica atributos do prototype
            enemy.health = self.health
            enemy.speed = self.speed
            enemy.damage = self.damage
            enemy.scare_range = self.scare_range
            enemy.scare_duration = self.scare_duration
            enemy.scare_cooldown = self.scare_cooldown
            
            return enemy
        
        def configure(self, **kwargs):
            """Permite configurar atributos espec√≠ficos"""
            self.health = kwargs.get('health', self.health)
            self.speed = kwargs.get('speed', self.speed)
            self.damage = kwargs.get('damage', self.damage)
    ```

???+ note "Inicializa√ß√£o e Uso do Sistema"
    O sistema √© inicializado no `GameMain.py` atrav√©s da fun√ß√£o `initialize_enemy_prototypes()`, que registra os prot√≥tipos dispon√≠veis no registry. O uso pr√°tico ocorre no `Level.py` onde inimigos s√£o criados atrav√©s da factory.

    ```python
    # Inicializa√ß√£o dos prot√≥tipos (GameMain.py)
    def initialize_enemy_prototypes():
        try:
            from Model.Enemies.bichopapao import BichoPapaoPrototype
            
            EnemyPrototypeRegistry.register("bicho_papao", BichoPapaoPrototype())
            print("[EnemyPrototype] Prot√≥tipos inicializados")
            
        except ImportError as e:
            print(f"[EnemyPrototype] ERRO: {e}")

    # Uso pr√°tico (Level.py)
    @classmethod
    def inicializar_mapa(cls):
        """Inicializa o mapa l√≥gico e a popula√ß√£o inicial."""
        cls.MAPA_LOGICO = [[0] * NUM_COLUNAS for _ in range(NUM_LINHAS)] 
        
        # Cria√ß√£o de inimigo usando o padr√£o Prototype
        linha_bp = random.randint(0, NUM_LINHAS - 1)
        EnemyFactory.create_enemy("bicho_papao", NUM_COLUNAS - 1, linha_bp)
    ```

Portanto, assim ficou modelado em UML, o padr√£o Prototype no c√≥digo do jogo. Clique aqui para [acessar](https://drive.google.com/file/d/1rMZls5VtM-wKu4dU8n61XUSBa_D9p5th/view?usp=sharing)

[![Ver UML do Prototype](../assets/GoFsCriacionais/prototype.png)](https://app.diagrams.net/#G1rMZls5VtM-wKu4dU8n61XUSBa_D9p5th#%7B%22pageId%22%3A%22x8WGHtwybbcXZKM1W8ie%22%7D)

O diagrama acima ilustra a **arquitetura de classes respons√°vel pela cria√ß√£o de inimigos** no jogo, evidenciando como o **Padr√£o de Projeto Prototype** foi aplicado para permitir a clonagem e configura√ß√£o flex√≠vel de diferentes tipos de entidades inimigas atrav√©s de prot√≥tipos pr√©-configurados.

No topo, encontra-se a classe **`EnemyFactory`**, que atua como o **cliente principal** do padr√£o. Ela possui m√©todos como `create_enemy()` e `create_random_enemy()`, que **delegam a cria√ß√£o** para o registry de prot√≥tipos, mantendo uma interface simples e desacoplada para os consumidores do sistema.

Logo abaixo, a classe **`EnemyPrototypeRegistry`** funciona como o **gerenciador centralizado** de todos os prot√≥tipos dispon√≠veis. Ela define funcionalidades essenciais, como:

- `_prototypes`: dicion√°rio que armazena as inst√¢ncias dos prot√≥tipos registrados.  
- `register()`: m√©todo para cadastrar novos tipos de prot√≥tipos no sistema.  
- `create()`: m√©todo que localiza o prot√≥tipo apropriado e executa sua clonagem.  
- `get_types()`: m√©todo que retorna os tipos de inimigos dispon√≠veis para cria√ß√£o.

A interface **`IEnemyPrototype`** estabelece o **contrato base** para todos os prot√≥tipos, definindo o m√©todo `clone()` que deve ser implementado pelas classes concretas. Essa abstra√ß√£o garante que o registry possa trabalhar com qualquer tipo de prot√≥tipo sem conhecer suas especificidades.

As classes derivadas de `IEnemyPrototype` representam os **prot√≥tipos espec√≠ficos de cada tipo de inimigo**:

- **`BichoPapaoPrototype`**: implementa a clonagem do BichoPapao, mantendo atributos configur√°veis como `health`, `speed`, `damage`, `scare_range`, `scare_duration` e `scare_cooldown`. Possui m√©todos especializados como `create_enemy()` para gerar a inst√¢ncia final e `configure()` para personaliza√ß√£o de atributos.

A classe **`BichoPapao`** representa o **produto final** criado pelo prot√≥tipo, sendo uma entidade concreta do jogo que herda de `Enemy`. Ela cont√©m toda a l√≥gica espec√≠fica do comportamento do Bicho-Pap√£o, incluindo:

- Atributos de posicionamento (`grid_x`, `grid_y`, `pos_x`, `pos_y`)
- Recursos visuais (`walk_animation`, `attack_animation`, `current_frame`)  
- Comportamentos especializados (`update()`, `attack()`, `_scare_defense()`)

Essa organiza√ß√£o reflete o uso do **Prototype** aliado √† **separa√ß√£o de responsabilidades**:

- O `EnemyFactory` **abstrai** a complexidade de cria√ß√£o para os clientes.  
- O `EnemyPrototypeRegistry` **centraliza** o gerenciamento dos prot√≥tipos dispon√≠veis.
- Cada prot√≥tipo **encapsula** a l√≥gica de clonagem e configura√ß√£o de seu tipo espec√≠fico.
- Os produtos finais **implementam** o comportamento real das entidades no jogo.

Em resumo, o diagrama mostra **uma arquitetura flex√≠vel e extens√≠vel**, em que o Prototype (`IEnemyPrototype` e suas implementa√ß√µes) permite a cria√ß√£o eficiente de inimigos atrav√©s de clonagem, enquanto o Registry centraliza o gerenciamento e a Factory oferece uma interface simplificada, favorecendo a **reutiliza√ß√£o de configura√ß√µes** e o **baixo acoplamento** entre os m√≥dulos do sistema.

### 3.1.5.2. Opni√µes dos Participantes

A elabora√ß√£o desta etapa foi realizada de forma colaborativa em reuni√£o pelo Discord, n√£o gravada, onde os todos membros designados estiveram presentes e participaram ativamente da discuss√£o/elabora√ß√£o.
O processo da execu√ß√£o do c√≥digo foi feito no Visual Studio Code e a elabora√ß√£o da UML foi feita no Draw.io, ferramenta que possibilitou a cria√ß√£o e edi√ß√£o simult√¢nea do diagrama, garantindo integra√ß√£o e alinhamento entre os integrantes.

Ao longo da atividade, cada integrante trouxe ideias e feedbacks que ajudaram a consolidar um resultado alinhado com a vis√£o do grupo como um todo. Esse processo coletivo contribuiu tanto para a consist√™ncia do diagrama quanto para o fortalecimento da colabora√ß√£o na equipe.

<details>
  <summary><strong><a href="https://github.com/danielle-soaress">Danielle Soares</a></strong></summary>
  <p>Achei o Prototype simples de entender e, para mim, foi o padr√£o mais f√°cil de identificar no nosso c√≥digo do jogo, j√° que o spawn de mobs √© um exemplo claro de clonagem de objetos. Nesse sentido, a √∫nica dificuldade foi na implementa√ß√£o do c√≥digo, mas acredito que o trabalho em equipe facilitou bastante essa parte. A elabora√ß√£o do diagrama UML tamb√©m foi bem tranquila.</p>
</details>

<details>
  <summary><strong><a href="https://github.com/EnzoEmir">Enzo Emir</a></strong></summary>
  <p>No in√≠cio, fiquei em d√∫vida sobre como implementar esse padr√£o no projeto. No entanto, ap√≥s conversar com o restante da equipe e discutir poss√≠veis abordagens, a ideia de aplic√°-lo nas entidades tornou-se muito mais compreens√≠vel.Essa troca de ideias ajudou a visualizar melhor os benef√≠cios do padr√£o e a forma como ele poderia tornar o c√≥digo mais organizado e flex√≠vel</p>
</details>

<details>
  <summary><strong><a href="https://github.com/Leticia-Arisa-K-Higa">Leticia Arisa</a></strong></summary>
  <p>Sobre o Prototype, eu achei bem interessante e f√°cil de entender. Ele ajuda a criar c√≥pias de objetos de forma pr√°tica, sem precisar construir tudo do zero. No nosso projeto, isso ficou claro no spawn de mobs, que usa clonagem de um modelo base. Achei legal ver como esse padr√£o facilita o c√≥digo e deixa o desenvolvimento mais r√°pido.</p>
</details>

<details>
  <summary><strong><a href="https://github.com/MM4K">Marcelo Makoto</a></strong></summary>
  <p>No come√ßo eu fiquei confuso sobre como implementar o padr√£o Prototype no nosso projeto, mas, quando estudei melhor, foi relativamente simples de implement√°-lo. Ele tornou a cria√ß√£o de entidades id√™nticas muito mais intuitiva e pr√°tica, sendo essencial para o futuro do projeto.</p>
</details>

<details>
  <summary><strong><a href="https://github.com/dudaa28">Maria Eduarda Andrade</a></strong></summary>
  <p>Eu acho que o padr√£o Prototype √© bem √∫til quando precisamos criar c√≥pias de objetos rapidamente, sem ter que recriar tudo do zero. Ele funciona bem em situa√ß√µes como jogos, onde voc√™ pode "clonar" um n√≠vel e s√≥ fazer ajustes pequenos. No come√ßo, pode ser um pouco confuso, igual o que aconteceu com o Iterator, mas depois que a gente entende a ideia de "clonar" objetos, fica muito mais f√°cil e eficiente de usar.</p>
</details>

### 3.1.5.3. V√≠deo Demonstrativo

Foi gravado, na plataforma do Microsoft Teams, uma reuni√£o para a modelagem UML do padr√£o Prototype e a execu√ß√£o do c√≥digo al√©m da explica√ß√£o do mesmo. Clique [aqui](https://www.youtube.com/watch?v=IraLkD6UEac) para acessar.


<iframe width="560" height="315" src="https://www.youtube.com/watch?v=IraLkD6UEac" title="YouTube video player" frameborder="0" allowfullscreen></iframe>


## 3.1.6. Refer√™ncias Bibliogr√°ficas

> <a id="REF1">1.</a> GAMMA, Erich et al. **Padr√µes de Projeto: Solu√ß√µes Reutiliz√°veis de Software Orientado a Objetos**. Tradu√ß√£o de C. F. Lucena e F. S. C. da Silva. Porto Alegre: Bookman, 2007. (T√≠tulo original: _Design Patterns: Elements of Reusable Object-Oriented Software_).

## 3.1.7. Hist√≥rico de Vers√µes üìÖ

| Vers√£o |    Data    |                Descri√ß√£o                |                  Autor(es)                   |                    Revisor(es)                     |
| :----: | :--------: | :-------------------------------------: | :------------------------------------------: | :------------------------------------------------: |
| `0.1`  | 23/10/2025 | Adicionando Documenta√ß√£o GoF Criacional | [Caio Duarte](https://github.com/caioduart3), [Laryssa F√©lix](https://github.com/felixlaryssa) | [Victor Pontual](https://github.com/VictorPontual) |
| `0.2`  | 23/10/2025 | Corre√ß√£o de numera√ß√£o, formata√ß√£o do c√≥digo, adi√ß√£o de v√≠deo e melhorias na documenta√ß√£o | [Victor Pontual](https://github.com/VictorPontual) | [Maria Eduarda Andrade](https://github.com/dudaa28) |
| `0.3`  | 24/10/2025 | Adicionando Documenta√ß√£o GoF Criacional | [Danielle Soares](https://github.com/danielle-soaress), [Enzo Emir](https://github.com/EnzoEmir), [Leticia Arisa](https://github.com/Leticia-Arisa-K-Higa), [Marcelo Makoto](https://github.com/MM4k), [Maria Eduarda](https://github.com/dudaa28)  | - |
