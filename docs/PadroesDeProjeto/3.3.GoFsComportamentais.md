# 3.3. M√≥dulo Padr√µes de Projeto GoFs Comportamentais

## 3.3.1. Introdu√ß√£o

Os **Padr√µes de Projeto Comportamentais** fazem parte do conjunto de solu√ß√µes proposto pela "Gang of Four" (GoF) <a href="#REF1">[1]</a> para lidar com desafios recorrentes na modelagem de sistemas orientados a objetos. Enquanto os padr√µes Criacionais tratam da inst√¢ncia√ß√£o de objetos e os Estruturais da organiza√ß√£o entre classes e interfaces, os **Comportamentais** concentram-se na **din√¢mica da comunica√ß√£o entre objetos**, promovendo uma colabora√ß√£o mais eficaz e desacoplada.

Esses padr√µes s√£o fundamentais para estabelecer **fluxos de controle flex√≠veis**, permitindo que algoritmos sejam encapsulados e substitu√≠dos sem afetar o restante da aplica√ß√£o. Ao distribuir responsabilidades de forma estrat√©gica, eles **favorecem a manuten√ß√£o, extensibilidade e reutiliza√ß√£o do c√≥digo** <a href="#REF2">[2]</a>. No contexto do desenvolvimento de jogos eletr√¥nicos, por exemplo, sua aplica√ß√£o permite modularizar comportamentos complexos e din√¢micos, como demonstrado por Figueiredo em sua disserta√ß√£o <a href="#REF3">[3]</a>, tornando os sistemas mais adapt√°veis √†s exig√™ncias de interatividade e evolu√ß√£o constante.

## Participantes

<font size="3"><p style="text-align: center">Tabela 1: Participantes</p></font>

<div align="center">
<table>
  <thead>
    <tr>
      <th>Nome</th>
      <th>Fun√ß√£o</th>
      <th>Data</th>
      <th>Hora</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><a href="https://github.com/caioduart3">Caio Duarte</a></td>
      <td>GoF Comportamental - State</td>
      <td>22/10/2025</td>
      <td>20:00</td>
    </tr>
    <tr>
      <td><a href="https://github.com/danielle-soaress">Danielle Soares</a></td>
      <td>GoF Comportamental - Iterator</td>
      <td>22/10/2025</td>
      <td>19:30</td>
    </tr>
    <tr>
      <td><a href="https://github.com/EnzoEmir">Enzo Emir</a></td>
      <td>GoF Comportamental - Strategy</td>
      <td>21/10/2025</td>
      <td>20:00</td>
    </tr>
    <tr>
      <td><a href="https://github.com/felixlaryssa">Laryssa F√©lix</a></td>
      <td>GoF Comportamental -  Strategy</td>
      <td>21/10/2025</td>
      <td>20:00</td>
    </tr>
    <tr>
      <td><a href="https://github.com/Leticia-Arisa-K-Higa">Leticia Arisa</a></td>
      <td>GoF Comportamental - Iterator</td>
      <td>22/10/2025</td>
      <td>19:30</td>
    </tr>
    <tr>
      <td><a href="https://github.com/MM4k">Marcelo Makoto</a></td>
      <td>GoF Comportamental - State</td>
      <td>22/10/2025</td>
      <td>20:00</td>
    </tr>
    <tr>
      <td><a href="https://github.com/dudaa28">Maria Eduarda</a></td>
      <td>GoF Comportamental - Iterator</td>
      <td>22/10/2025</td>
      <td>19:30</td>
    </tr>
    <tr>
      <td><a href="https://github.com/RafaelSchadt">Rafael Welz</a></td>
      <td>GoF Comportamental - Strategy</td>
      <td>21/10/2025</td>
      <td>20:00</td>
    </tr>
    <tr>
      <td><a href="https://github.com/VictorPontual">Victor Pontual</a></td>
      <td>GoF Comportamental - State</td>
      <td>20/10/2025</td>
      <td>11:00</td>
    </tr>
  </tbody>
</table>
</div>

<font size="2"><p style="text-align: center">Fonte: Equipe do Projeto, 2025.</p></font>


## 3.3.2. Metodologia

A pesquisa e o desenvolvimento do estudo dos Padr√µes de Projeto Comportamentais foram conduzidos seguindo uma abordagem pr√°tica e colaborativa, focada na aplica√ß√£o real dos conceitos em um sistema de *software* existente.

### 3.3.2.1. Revis√£o e Sele√ß√£o de Padr√µes
Iniciou-se com a revis√£o do cat√°logo de Padr√µes de Projeto Comportamentais da "Gang of Four" (GoF), conforme introduzido na se√ß√£o anterior. Foram selecionados os padr√µes mais relevantes para resolver problemas de intera√ß√£o e comunica√ß√£o observados no **software interno do jogo**, que est√° hospedado em um reposit√≥rio de c√≥digo separado.

### 3.3.2.2. Aplica√ß√£o e Implementa√ß√£o
Os padr√µes de projeto selecionados (*Strategy*, *Iterator* e *State*) foram implementados diretamente no c√≥digo-fonte do *software* interno do jogo. Esta etapa foi crucial para testar a efic√°cia dos padr√µes na redu√ß√£o do acoplamento, melhoria da legibilidade e aumento da flexibilidade do sistema.

### 3.3.2.3. Modelagem e Documenta√ß√£o UML
Para documentar visualmente a estrutura e a aplica√ß√£o dos padr√µes, o *software* **Draw.io** foi utilizado para a cria√ß√£o de **Diagramas UML (Linguagem de Modelagem Unificada)**. Esses diagramas (principalmente de Classe e/ou Sequ√™ncia) serviram para mapear as novas intera√ß√µes e rela√ß√µes entre os objetos resultantes da aplica√ß√£o dos padr√µes Comportamentais.

### 3.3.2.4. Demonstra√ß√£o e Colabora√ß√£o
Para garantir a transpar√™ncia do processo e documentar a participa√ß√£o de cada membro, as sess√µes de desenvolvimento, discuss√µes t√©cnicas e demonstra√ß√µes de execu√ß√£o do c√≥digo foram **gravadas por meio da plataforma Microsoft Teams**. Essas grava√ß√µes serviram como artefatos de evid√™ncia, demonstrando a aplica√ß√£o pr√°tica dos padr√µes, o fluxo de trabalho colaborativo e a contribui√ß√£o individual dos membros da equipe na solu√ß√£o dos problemas de design.

## **3.3.3. Strategy**

O padr√£o **Strategy** √© um dos padr√µes comportamentais definidos pela Gang of Four (GoF) e tem como objetivo **encapsular algoritmos ou comportamentos distintos dentro de classes separadas**, permitindo que eles sejam intercambi√°veis em tempo de execu√ß√£o.
Em vez de implementar diretamente um comportamento em uma classe, o Strategy prop√µe que esse comportamento seja delegado a um objeto externo, chamado de estrat√©gia. Isso promove a **flexibilidade e o desacoplamento,** pois novas estrat√©gias podem ser adicionadas ou modificadas sem alterar o c√≥digo da classe principal.
Esse padr√£o √© especialmente √∫til quando h√° **m√∫ltiplas varia√ß√µes de um mesmo processo,** como diferentes formas de ordena√ß√£o, c√°lculo ou movimenta√ß√£o em jogos, por exemplo. Ao aplicar o Strategy, o sistema se torna mais extens√≠vel e test√°vel.

## **3.3.3.1. Diagrama UML**

O GoF Comportamental *Strategy* foi aplicado ao projeto, nos seguintes c√≥digos:

![diret√≥rio do c√≥digo](../assets/GoFsEstruturais/arquivosStrategy.png)

<font size="2"><p style="text-align: center">Fonte: [Laryssa Felix](https://github.com/felixlaryssa), [Enzo Emir]("https://github.com/EnzoEmir"), [Rafael Welz](https://github.com/RafaelSchadt) , 2025.</p></font>

???+ note "Aplica√ß√£o do Padr√£o Strategy (N√≠veis de Dificuldade)"
    O trecho de c√≥digo a seguir, extra√≠do do arquivo (`DifficultySelector.py`), demonstra     
    a aplica√ß√£o do Padr√£o Strategy atrav√©s da cria√ß√£o de diferentes estrat√©gias de      
    *`dificuldade`*    (`EasyStrategy`, `NormalStrategy` e `HardStrategy`), todas herdando da interface abstrata `StrategyDifficulty`.  
    O seletor de dificuldade (`DifficultySelector`) atua como o contexto, delegando dinamicamente o comportamento conforme o n√≠vel selecionado pelo jogador.

    ```python
        import pygame
        from abc import ABC, abstractmethod

            class StrategyDifficulty(ABC):
                
                @abstractmethod
                def obter_multiplicador_vida(self) -> float: ...
                @abstractmethod
                def obter_multiplicador_ataque(self) -> float: ...
                @abstractmethod
                def obter_multiplicador_velocidade(self) -> float: ...
                
                def aplicar_regras(self):
                    print(f"[Core Log] Estrat√©gia de Dificuldade '{self.__class__.__name__}' aplicada.")


            class EasyStrategy(StrategyDifficulty):
                def obter_multiplicador_vida(self): return 0.7
                def obter_multiplicador_ataque(self): return 0.7
                def obter_multiplicador_velocidade(self): return 0.9


            class NormalStrategy(StrategyDifficulty):
                def obter_multiplicador_vida(self): return 1.0
                def obter_multiplicador_ataque(self): return 1.0
                def obter_multiplicador_velocidade(self): return 1.0


            class HardStrategy(StrategyDifficulty):
                def obter_multiplicador_vida(self): return 1.5
                def obter_multiplicador_ataque(self): return 1.5
                def obter_multiplicador_velocidade(self): return 1.2


            class DifficultySelector:
                _strategy: StrategyDifficulty | None = None
                _nivel: str = 'normal'

                @classmethod
                def inicializar(cls, nivel='normal'):
                    cls.set_difficulty(nivel)

                @classmethod
                def set_difficulty(cls, nivel):
                    mapping = {'easy': EasyStrategy, 'normal': NormalStrategy, 'hard': HardStrategy}
                    cls._strategy = mapping.get(nivel.lower(), NormalStrategy)()
                    cls._nivel = nivel
                    cls._strategy.aplicar_regras()

                @classmethod
                def obter_multiplicador_vida(cls): return cls._strategy.obter_multiplicador_vida()
                @classmethod
                def obter_multiplicador_ataque(cls): return cls._strategy.obter_multiplicador_ataque()
                @classmethod
                def obter_multiplicador_velocidade(cls): return cls._strategy.obter_multiplicador_velocidade()
                @classmethod
                def get_current_level(cls): return cls._nivel
    ```

???+ note "Interface Visual de Sele√ß√£o de Dificuldade"
    J√° a interface visual para essa escolha est√° definida em `src/View/DifficultScreen.py`.  
    O arquivo `DifficultScreen.py` controla a l√≥gica de intera√ß√£o do jogador, e o `DifficultScreenRenderer.py` cuida da renderiza√ß√£o dos elementos gr√°ficos da tela de sele√ß√£o de dificuldade.

    ```python
        import pygame
        from Template.BaseScreen import BaseScreen
        from View.DifficultScreen.DifficultScreenRenderer import DifficultScreenRenderer
        from View.ViewRenderer import ViewRenderer  
        from View.InputHandler import InputHandler, InputType
        from enum import Enum

        class Difficulty(Enum):
            EASY = "easy"
            MEDIUM = "medium"
            HARD = "hard"

        class DifficultScreen(BaseScreen):
            def __init__(self):
                super().__init__()
                self.difficulties = {
                    Difficulty.EASY: {"name": "F√°cil", "color": (100, 200, 100), "hover_color": (120, 220, 120)},
                    Difficulty.MEDIUM: {"name": "M√©dio", "color": (200, 200, 100), "hover_color": (220, 220, 120)},
                    Difficulty.HARD: {"name": "Dif√≠cil", "color": (200, 100, 100), "hover_color": (220, 120, 120)}
                }
                self.selected_difficulty = None
                self.renderer = DifficultScreenRenderer(self)

            def handle_event(self, event):
                tipo = InputHandler.classificar_evento(event)
                pos = InputHandler.mouse_posicao()

                if tipo == InputType.MOUSE and event.type == pygame.MOUSEBUTTONDOWN:
                    for difficulty, rect in self.difficulty_rects.items():
                        if rect.collidepoint(pos):
                            self.selected_difficulty = difficulty
                            print(f"Dificuldade selecionada: {self.difficulties[difficulty]['name']}")
                            break

            def _iniciar_jogo(self):
                from Core.DifficultySelector import DifficultySelector
                DifficultySelector.set_difficulty(self.selected_difficulty.value)
                # a partir daqui o jogo √© iniciado com a estrat√©gia selecionada
    ```


Portanto, assim ficou modelado em UML, o padr√£o Strategy no c√≥digo do jogo. [Clique aqui](https://drive.google.com/file/d/1O_kNfro8bEsn3NAhUfbBjLvCst9_R5q0/view?usp=sharing)

[![Ver UML do Composite](../assets/GoFsEstruturais/Strategy.drawio.webp)](https://drive.google.com/file/d/1O_kNfro8bEsn3NAhUfbBjLvCst9_R5q0/view?usp=sharing)

<font size="2"><p style="text-align: center">Fonte: [Laryssa Felix](https://github.com/felixlaryssa), [Enzo Emir]("https://github.com/EnzoEmir"), [Rafael Welz](https://github.com/RafaelSchadt) , 2025.</p></font>

#### Estrutura e Responsabilidades

- **`StrategyDifficulty`**  
Classe abstrata que define o contrato das estrat√©gias de dificuldade, especificando os m√©todos necess√°rios para determinar os multiplicadores de vida, ataque e velocidade.

- **`EasyStrategy, NormalStrategy, HardStrategy`**  
Implementa√ß√µes concretas do contrato de `StrategyDifficulty`.  
Cada uma define seus pr√≥prios multiplicadores, influenciando diretamente o equil√≠brio do jogo.

- **`DifficultySelector`**  
Atua como o contexto do padr√£o.  
Ele gerencia a estrat√©gia ativa e fornece m√©todos centralizados para recuperar os multiplicadores atuais, tornando a l√≥gica de dificuldade independente da camada de visualiza√ß√£o.

- **`DifficultScreen`**  
Classe respons√°vel pela intera√ß√£o do jogador, exibindo op√ß√µes de dificuldade e chamando `DifficultySelector.set_difficulty()` ao iniciar o jogo.

- **`DifficultScreenRenderer`**  
Respons√°vel pela renderiza√ß√£o gr√°fica da interface, apresentando os cart√µes de dificuldade com feedback visual (sele√ß√£o, hover, desabilitado).

#### Benef√≠cios da Aplica√ß√£o

- **Flexibilidade:** novas dificuldades podem ser adicionadas facilmente, bastando criar uma nova classe que herde de `StrategyDifficulty`.
- **Baixo acoplamento:** o c√≥digo de renderiza√ß√£o e intera√ß√£o n√£o depende de detalhes de implementa√ß√£o da dificuldade.
- **Extensibilidade:** permite ajustar regras de vida, dano e velocidade sem alterar a estrutura central do jogo.
- **Coes√£o:** cada classe tem uma responsabilidade clara e isolada (render, l√≥gica de input, regras do jogo, etc.).

Esse design evidencia o uso bem estruturado do **GoF Comportamental Strategy**, ao encapsular varia√ß√µes de comportamento (n√≠veis de dificuldade) em classes independentes e permitir que o jogo altere sua l√≥gica de forma modular, escal√°vel e de f√°cil manuten√ß√£o.



### 3.3.3.2. Opini√µes dos Participantes

A elabora√ß√£o desta etapa foi realizada de forma colaborativa em reuni√£o pelo **Discord**, n√£o gravada,  onde os tr√™s membros designados estiveram presentes e participaram ativamente da discuss√£o/elabora√ß√£o.  
O processo da execu√ß√£o do c√≥digo foi feito no **Visual Studio Code** e a elabora√ß√£o da UML foi feita no **Draw.io**, ferramenta que possibilitou a cria√ß√£o e edi√ß√£o simult√¢nea do diagrama, garantindo integra√ß√£o e alinhamento entre os integrantes.  

Ao longo da atividade, cada integrante trouxe ideias e feedbacks que ajudaram a consolidar um resultado alinhado com a vis√£o do grupo como um todo. Esse processo coletivo contribuiu tanto para a consist√™ncia do diagrama quanto para o fortalecimento da colabora√ß√£o na equipe.

<details>
  <summary><strong><a href="https://github.com/EnzoEmir">Enzo Emir</a></strong></summary>
  <p>Pesquisando percebi que uma vantagem do Strategy √© sua contribui√ß√£o para a testabilidade do sistema. Como os comportamentos est√£o isolados em classes espec√≠ficas, √© poss√≠vel testar cada estrat√©gia de forma independente, sem depender do contexto completo. Isso favorece a cria√ß√£o de simula√ß√µes controladas, especialmente √∫til em sistemas complexos ou com l√≥gica sens√≠vel, como IA de jogos, c√°lculos financeiros ou regras de neg√≥cio.</p>
</details>

<details>
  <summary><strong><a href="https://github.com/felixlaryssa">Laryssa F√©lix</a></strong></summary>
  <p>O padr√£o Strategy √© uma solu√ß√£o elegante para cen√°rios em que m√∫ltiplos comportamentos precisam ser alternados dinamicamente. Sua principal for√ßa est√° na flexibilidade: ao encapsular algoritmos em classes separadas, ele permite que o sistema evolua sem a necessidade de modificar o c√≥digo existente. Isso √© especialmente √∫til em jogos digitais, onde diferentes estilos de inimigos, n√≠veis de dificuldade ou modos de ataque podem ser implementados como estrat√©gias distintas.</p>
</details>

<details>
  <summary><strong><a href="https://github.com/RafaelSchadt">Rafael Schadt</a></strong></summary>
  <p>A implementa√ß√£o do padr√£o Strategy para as dificuldades do jogo (Easy, Normal, Hard) pareceu desnecessariamente complexa √† primeira vista. Questionei a necessidade de m√∫ltiplas classes quando uma condicional b√°sica resolvia. No entanto, o valor veio na pr√°tica: encapsular cada regra de dificuldade isoladamente garantiu uma estrutura impec√°vel. A adi√ß√£o de novos modos (mesmo que futuramente) se tornou trivial e limpa, confirmando a efic√°cia e eleg√¢ncia do padr√£o.</p>
</details>

### 3.3.3.3. V√≠deo Demonstrativo

Foi gravado, na plataforma do Microsoft Teams, uma reuni√£o para a modelagem UML do padr√£o Strategy e a execu√ß√£o do c√≥digo al√©m da explica√ß√£o do mesmo. Clique [aqui](https://youtu.be/62f51kDLWNQ?si=3HCpRg2Mn46kOYO0) para acessar.


<div style="text-align: center;">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/QKZyKbrpQQ8?si=gybvhCSWl1TLhJGv" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</div>


## **3.3.4. Iterator**

O padr√£o Iterator √© um padr√£o de projeto comportamental que fornece uma maneira de sequencialmente os elementos de um objeto de cole√ß√£o sem expor sua representa√ß√£o interna (lista, pilha, √°rvore, etc.)

A inten√ß√£o principal √© permitir que os clientes (c√≥digo que utiliza a estrutura) percorram a cole√ß√£o usando uma interface comum, independentemente da estrutura de dados espec√≠fica que a implementa.

### **3.3.4.1 Diagrama UML**

O GoF Comportamental Interator foi aplicado ao projeto, nos seguintes c√≥digos:

???+ note "Interface Iterador"
    ```python
    from abc import ABC, abstractmethod
    from typing import TypeVar, Generic


    T = TypeVar('T')




    class IIterator(ABC, Generic[T]):
    """
    Declara as opera√ß√µes necess√°rias para percorrer uma cole√ß√£o.
    """
    
    @abstractmethod
    def getNext(self) -> T:
        """
        Pega o pr√≥ximo elemento da itera√ß√£o.
        """
        pass


    @abstractmethod
    def hasMore(self) -> bool:
        """
        Verifica se ainda h√° elementos para percorrer.
        """
        pass


    @abstractmethod
    def getPosition(self) -> int:
        """
        Retorna o √≠ndice ou posi√ß√£o atual do iterador.
        """
        pass


    @abstractmethod
    def restart(self):
        """
        Reinicia o iterador, voltando para a primeira posi√ß√£o.
        """
        pass




    class IIterableCollection(ABC, Generic[T]):
    """
    Declara um ou mais m√©todos para obter iteradores.
    """
    
    @abstractmethod
    def createIterator(self) -> IIterator[T]:
        """
        Retorna uma nova inst√¢ncia de um iterador compat√≠vel.
        """
        pass
    ```

???+ note "Iteradores Concretos"
    ```python
    import pygame
    from typing import TypeVar
    from .interfaces import IIterator, IIterableCollection


    # Define que 'T' deve ser sempre um tipo de Sprite
    T = TypeVar('T', bound=pygame.sprite.Sprite)




    class SpriteGroupIterator(IIterator[T]):
    
    def __init__(self, group: pygame.sprite.Group):
        # No exato momento da cria√ß√£o do iterador √© tirado um "snapshot"
        # (Uma c√≥pia da lista que iterador ir√° percorrer)
        self._snapshot: list[T] = group.sprites()
        self._count: int = len(self._snapshot)
        self._position: int = 0


    def getNext(self) -> T:
        # Pega o pr√≥ximo elemento da itera√ß√£o se houver
        if self.hasMore():
            sprite = self._snapshot[self._position]
            self._position += 1
            return sprite
        else:
            raise StopIteration("N√£o h√° mais elementos na itera√ß√£o.")


    def hasMore(self) -> bool:
        # Verifica se h√° mais elementos para iterar
        return self._position < self._count


    def getPosition(self) -> int:
        # Retorna a posi√ß√£o atual do iterador
        return self._position


    def restart(self):
        # Reinicia o iterador, voltando para a primeira posi√ß√£o do snapshot
        self._position = 0






    class IterableSpriteGroup(IIterableCollection[T]):
    # Essa classe age como um adaptador para pygame.sprite.Group
    
    def __init__(self, group: pygame.sprite.Group):
        self._group = group


    def createIterator(self) -> IIterator[T]:
        # Cria um novo iterador, que vai tirar um novo snapshot
        return SpriteGroupIterator[T](self._group)
    
    def get_raw_group(self) -> pygame.sprite.Group:
        # M√©todo auxiliar para acessar o grupo original, se necess√°rio
        return self._group
    ```

???+ note "Cliente"
    ```python
    import pygame
    from Model.interfaces import IIterableCollection
    from Model.Defense.caipora import Caipora
    from Model.Enemies.enemy import Enemy
    from Model.Items.arrow import Arrow


    class PhysicsEngine:
    @classmethod
    def processar_colisoes(
        cls,
        projeteis_col: IIterableCollection[Arrow],
        inimigos_col: IIterableCollection[Enemy],
        caiporas_col: IIterableCollection[Caipora]
    ):
        # Colis√£o de proj√©teis com inimigos


        # Pega o iterador de proj√©teis e cria um snapshot da lista de proj√©teis
        iter_projeteis = projeteis_col.createIterator()
        
        # Percorre o snapshot de proj√©teis
        while iter_projeteis.hasMore():
            projetil = iter_projeteis.getNext()
            
            # Para cada proj√©til √© criado um novo iterador de inimigos
            iter_inimigos = inimigos_col.createIterator()
            
            #Percorre o snapshot de inimigos
            while iter_inimigos.hasMore():
                inimigo = iter_inimigos.getNext()
                
                # Checa colis√£o entre o proj√©til e o inimigo
                if pygame.sprite.collide_rect(projetil, inimigo):
                    
                    # Usa o dano do proj√©til para reduzir a vida do inimigo
                    inimigo.health -= projetil.damage
                    
                    if inimigo.health <= 0:
                        inimigo.kill() # Remove do grupo original
                    projetil.kill() # Remove o proj√©til do grupo original
                    break
        
        # Colis√£o de inimigos com defesas
        
        # Cria uma nova itera√ß√£o de inimigos
        iter_inimigos_ataque = inimigos_col.createIterator()
        
        # Percorre o snapshot de inimigos
        while iter_inimigos_ataque.hasMore():
            inimigo = iter_inimigos_ataque.getNext()
            
            # Para cada inimigo, cria um novo iterador de Caiporas
            iter_caiporas = caiporas_col.createIterator()
            defesas_na_linha = [] # Lista tempor√°ria
            
            # Percorre o snapshot de Caiporas
            while iter_caiporas.hasMore():
                defesa = iter_caiporas.getNext()
                if defesa.grid_y == inimigo.grid_y:
                    defesas_na_linha.append(defesa)


            # L√≥gica de ataque
            atacou_alguem = False
            for defesa in defesas_na_linha:
                if pygame.sprite.collide_rect(inimigo, defesa):
                    inimigo.is_attacking = True
                    atacou_alguem = True
                    
                    if hasattr(inimigo, 'attack'):
                        inimigo.attack(defesa)
                    else:
                        defesa.health -= inimigo.damage * 0.1
                    
                    if defesa.health <= 0:
                        defesa.kill()
                    
                    break # Inimigo ataca apenas uma defesa por vez
            
            if not atacou_alguem:
                inimigo.is_attacking = False
    ```

Portanto, assim ficou o modelado em UML, o padr√£o Iterator no c√≥digo do jogo. Clique aqui para [acessar](https://lucid.app/lucidchart/a58df264-4099-40c8-a297-f861f85902dc/edit?viewport_loc=96%2C171%2C928%2C969%2CHWEp-vi-RSFO&invitationId=inv_6291038a-46f6-46f2-bd92-54e99f058a5e):


[![Ver UML do Iterator](../assets/GoFsComportamentais/Iterator.svg)](https://lucid.app/lucidchart/a58df264-4099-40c8-a297-f861f85902dc/edit?viewport_loc=96%2C171%2C928%2C969%2CHWEp-vi-RSFO&invitationId=inv_6291038a-46f6-46f2-bd92-54e99f058a5e)

O diagrama acima ilustra a arquitetura de classes respons√°vel pelo **processamento de colis√µes** no jogo, evidenciando como o **Padr√£o de Projeto Iterador** foi aplicado para permitir que a l√≥gica de f√≠sica percorra diferentes cole√ß√µes de entidades (como inimigos, proj√©teis e defesas) de maneira uniforme.

No centro do padr√£o, encontram-se as duas interfaces principais:

- **IterableCollection (Agregado):** Define a interface para as cole√ß√µes que podem ser percorridas. Sua responsabilidade principal √© declarar o m√©todo de f√°brica **createIterator()**, que retorna um objeto Iterador.

- **Iterator:** Define a interface comum para percorrer os elementos da cole√ß√£o, abstraindo a estrutura interna. Ela inclui m√©todos essenciais como **getNext()** (para obter o pr√≥ximo item) e **hasMore()** (para verificar se a itera√ß√£o terminou).

Abaixo, est√£o as implementa√ß√µes concretas dessas interfaces:

- **IterableSpriteGroup (Agregado Concreto):** √â a classe que representa a cole√ß√£o de sprites em si (provavelmente encapsulando um **pygame.sprite.Group**). Ela implementa **IterableCollection** e sabe como criar seu iterador espec√≠fico.

- **SpriteGroupIterator (Iterador Concreto):** √â a classe que implementa a interface **Iterator**, contendo a l√≥gica espec√≠fica para percorrer os elementos dentro de um **IterableSpriteGroup**.

Finalmente, a classe **PhysicsEngine** atua como o Cliente do padr√£o. Ela depende apenas das interfaces (**IterableCollection** e **Iterator**), e n√£o das implementa√ß√µes concretas.

Como visto no c√≥digo, o m√©todo **processar_colisoes** recebe cole√ß√µes (como **projeteis_col**, **inimigos_col**) que obedecem √† interface **IIterableCollection**. Dentro do m√©todo, em vez de acessar diretamente a estrutura de dados dessas cole√ß√µes, o **PhysicsEngine** solicita um iterador atrav√©s de **projeteis_col.createIterator()**.

Em seguida, ele usa os m√©todos da interface do iterador (**while iter_projeteis.hasMore():** e **projetil = iter_projeteis.getNext()**) para processar cada elemento.

### **3.3.4.3. Opni√µes dos Participantes**

<details>
  <summary><strong><a href="https://github.com/danielle-soaress">Danielle Soares</a></strong></summary>
  <p> A minha experi√™ncia foi que eu achei um pouco dif√≠cil entender o Iterator dentro do nosso projeto.
  Geralmente, os exemplos que vemos relacionados a jogos est√£o sempre ligados a n√≠veis, um n√≠vel leva a outro, que leva a outro, e assim por diante. √â necess√°rio ter um iterator que aponte para o pr√≥ximo n√≠vel, e depois para o pr√≥ximo, e para o pr√≥ximo.
  Como a gente ainda n√£o tem o c√≥digo totalmente implementado, n√£o consegu√≠amos visualizar essa l√≥gica de n√≠veis claramente. Tivemos que buscar essa l√≥gica do iterator dentro do que j√° estava implementado, e isso foi um pouco dif√≠cil de identificar.
  Mas depois que entendemos o conceito, tudo ficou mais tranquilo. √â um conceito simples, mas o nome e toda a ideia por tr√°s dele, quando a gente v√™ pela primeira vez, podem assustar um pouco. </p>
</details>

<details>
  <summary><strong><a href="https://github.com/Leticia-Arisa-K-Higa">Leticia Arisa</a></strong></summary>
  <p> Sobre o Iterator, no come√ßo foi um pouco dif√≠cil para mim entender como o c√≥digo funcionava, mas depois comecei a compreender melhor. Quando parei para estudar com calma, percebi que n√£o era t√£o dif√≠cil assim. </p>
</details>

<details>
  <summary><strong><a href="https://github.com/dudaa28">Maria Eduarda</a></strong></summary>
  <p> Basicamente, a minha experi√™ncia foi um pouco complicada, principalmente por eu ainda ter pouca base em orienta√ß√£o a objetos. Ent√£o, ligar esse conhecimento com o padr√£o de projeto comportamental e tentar entender como ele funcionaria dentro do nosso projeto foi bastante dif√≠cil para mim.
  Felizmente, eu tive ajuda das minhas colegas de trabalho, o que tornou o processo um pouco mais tranquilo. Aos poucos, fui conseguindo entender e conectar tudo. Quando a gente vai conversando e trocando ideias, o entendimento flui melhor e conseguimos construir juntos.
  No fim, apesar de ter sido uma experi√™ncia dif√≠cil no come√ßo, depois da nossa apresenta√ß√£o eu consegui compreender bem o conceito, e fiquei satisfeita com o resultado. </p>
</details>


### **3.3.4.4. V√≠deo Demonstrativo**

Foi gravado, na plataforma do Microsoft Teams, uma reuni√£o para a modelagem UML do padr√£o Iterator e a explica√ß√£o do mesmo. Clique [aqui](https://www.youtube.com/watch?v=ZHCbX79w1hM) para acessar.


<div style="text-align: center;">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/ZHCbX79w1hM?si=EZVL_sRIikmOMIcO" title="YouTube video player" frameborder="0" allowfullscreen></iframe>
</div>



## **3.3.5. State**

O padr√£o **State** √© um padr√£o de projeto comportamental que permite a um objeto **alterar seu comportamento quando seu estado interno muda**. O objeto parecer√° mudar de classe <a href="#REF4">[4]</a>.

A inten√ß√£o principal √© permitir que um objeto altere seu comportamento sem mudar sua classe, encapsulando os comportamentos associados a estados espec√≠ficos em objetos separados.

### 3.3.5.1. Diagrama UML

O GoF Comportamental *State* foi aplicado ao projeto, no seguinte c√≥digo:

![diret√≥rio do c√≥digo](../assets/GoFsComportamentais/state_code_tree.png)

???+ note "Aplica√ß√£o do Padr√£o State (Gerenciamento de Comportamento)"
    O trecho de c√≥digo a seguir, extra√≠do do arquivo `AttackingState.py`, demonstra a implementa√ß√£o do Padr√£o State.
    A classe `AttackingState` encapsula o comportamento de uma unidade de defesa quando est√° no estado de ataque. Ela gerencia a l√≥gica de anima√ß√£o, a transi√ß√£o para outros estados (como `IdleState`) e a execu√ß√£o de a√ß√µes espec√≠ficas, como `atirar()`.

    ```python
    import pygame

    class AttackingState:
        
        def enter(self, defense) -> None:
            defense.atacando = True
            defense.animation_timer = 0
            print(f"[{defense.__class__.__name__}] Entrando em AttackingState")
        
        def exit(self, defense) -> None:
            defense.atacando = False
            defense.frame_index = 0
            if hasattr(defense, 'frames') and defense.frames:
                defense.image = defense.frames[defense.frame_index]
        
        def update(self, defense) -> None:
            from Model.sprite_groups import sprite_manager
            inimigos_grupo = sprite_manager.inimigos
            
            alvo_na_linha = any(
                e for e in inimigos_grupo 
                if e.grid_y == defense.grid_y and e.rect.right > defense.rect.right
            )
            
            if not alvo_na_linha:
                from Model.Defense.IdleState import IdleState
                defense.set_state(IdleState())
                return
            
            defense.animation_timer += 1
            if defense.animation_timer >= defense.frame_duration:
                if defense.frame_index == defense.FRAME_DE_TIRO:
                    defense.atirar()
                
                defense.frame_index = (defense.frame_index + 1) % len(defense.frames)
                defense.image = defense.frames[defense.frame_index]
                defense.animation_timer = 0
    ```

Portanto, assim ficou modelado em UML, o padr√£o State no c√≥digo do jogo. Clique aqui para [acessar](https://app.diagrams.net/#G1-AOeX1dT3uFPnL57hsZd-PovQyqNWL4R#%7B%22pageId%22%3A%22X3R_5GCPD2nqqYXSXyz-%22%7D):

[![Ver UML do State](../assets/GoFsComportamentais/uml_States.drawio.png)](../assets/GoFsComportamentais/uml_States.drawio.png)

O diagrama acima ilustra a aplica√ß√£o do **Padr√£o de Projeto State** para gerenciar o comportamento din√¢mico das entidades de defesa no jogo, como a `Caipora`. A arquitetura desacopla o comportamento de uma entidade de sua classe principal, permitindo que ela mude de comportamento em tempo de execu√ß√£o.

Os principais componentes do diagrama s√£o:

- **`State` (Interface)**: No topo, a interface `State` define o contrato que todos os estados concretos devem seguir. Ela declara os m√©todos essenciais que governam o ciclo de vida de um estado:
    - `enter(entity)`: Executado quando a entidade entra no estado.
    - `exit(entity)`: Executado quando a entidade sai do estado, para limpeza.
    - `update(entity)`: Chamado a cada quadro do jogo para executar a l√≥gica do estado.

- **`IdleState` e `AttackingState` (Estados Concretos)**: Estas classes implementam a interface `State` e encapsulam os comportamentos espec√≠ficos.
    - `IdleState`: Representa o estado ocioso, onde a defesa pode estar aguardando inimigos. Sua l√≥gica de `update` verifica as condi√ß√µes para transicionar para o `AttackingState` (por exemplo, se um inimigo entra no alcance).
    - `AttackingState`: Cont√©m a l√≥gica para quando a defesa est√° ativamente atacando. Seu `update` gerencia a anima√ß√£o de ataque e verifica se deve retornar ao `IdleState` (por exemplo, se n√£o h√° mais inimigos na linha).

- **`Defesa` (Contexto)**: A classe `Defesa` atua como o Contexto. Ela mant√©m uma refer√™ncia ao seu estado atual (um objeto que implementa `State`) e delega a execu√ß√£o do comportamento para esse objeto.
    - Possui um m√©todo `set_state(newState)` que permite a si mesma ou aos objetos de estado alterar seu estado atual, executando os m√©todos `exit()` do estado antigo e `enter()` do novo.
    - O m√©todo `update()` da `Defesa` simplesmente chama o `update()` de seu estado atual, garantindo que o comportamento correto seja executado.

- **`Caipora`**: √â uma implementa√ß√£o concreta da `Defesa`, representando uma unidade espec√≠fica do jogo que utiliza essa m√°quina de estados para controlar seu comportamento.

Essa estrutura permite que o comportamento da `Caipora` mude dinamicamente entre "ocioso" e "atacando" sem usar condicionais complexas dentro da classe `Caipora`, tornando o c√≥digo mais limpo, organizado e f√°cil de estender com novos estados.

### 3.3.5.2. Opini√µes dos Participantes

A elabora√ß√£o desta etapa foi realizada de forma colaborativa em reuni√£o pelo *Discord*, n√£o gravada, onde os tr√™s membros designados estiveram presentes e participaram ativamente da discuss√£o/elabora√ß√£o.
O processo da execu√ß√£o do c√≥digo foi feito no *Visual Studio Code* e a elabora√ß√£o da UML foi feita no *Draw.io*, ferramenta que possibilitou a cria√ß√£o e edi√ß√£o simult√¢nea do diagrama, garantindo integra√ß√£o e alinhamento entre os integrantes.

Ao longo da atividade, cada integrante trouxe ideias e feedbacks que ajudaram a consolidar um resultado alinhado com a vis√£o do grupo como um todo. Esse processo coletivo contribuiu tanto para a consist√™ncia do diagrama quanto para o fortalecimento da colabora√ß√£o na equipe.

<details>
  <summary><strong><a href="https://github.com/caioduart3">Caio Duarte</a></strong></summary>
  <p>Gostei muito do padr√£o, achei algo bem diferente e fora da caixinha a l√≥gica dele de controlar estados, creio que ele encaixou muito bem no nosso trabalho ao controlar os estados das entidades.</p>
</details>

<details>
  <summary><strong><a href="https://github.com/MM4k">Marcelo Makoto</a></strong></summary>
  <p>Implementar o padr√£o de States foi bem mais intuitivo do que eu imaginei no come√ßo. Ele tamb√©m se torna crucial no nosso projeto, visto que a quantidade de entidades aumentar√° cada vez mais com a evolu√ß√£o do jogo e esse padr√£o ajudar√° na organiza√ß√£o do projeto e na implementa√ß√£o de novas entidades.</p>
</details>

<details>
  <summary><strong><a href="https://github.com/VictorPontual">Victor Pontual</a></strong></summary>
  <p>Implementar o State Pattern foi revelador ‚Äî antes eu usava flags booleanas e condicionais espalhados para gerenciar comportamentos dos personagens, o que funcionava mas ficava confuso. Ao aprender o padr√£o formal, percebi que j√° fazia algo parecido de forma "casual", s√≥ que agora com estrutura adequada: cada comportamento virou uma entidade independente, transi√ß√µes ficaram expl√≠citas, e adicionar novos estados se tornou trivial sem mexer no c√≥digo existente. Foi daqueles momentos onde voc√™ aprende a nomenclatura oficial de algo que j√° fazia intuitivamente, transformando um "sistema improvisado" em arquitetura elegante e escal√°vel.</p>
</details>

### 3.3.5.3. V√≠deo Demonstrativo

Foi gravada, na plataforma do Microsoft Teams, uma reuni√£o para a modelagem UML do padr√£o State e a execu√ß√£o do c√≥digo al√©m da explica√ß√£o do mesmo. Clique [aqui](https://www.youtube.com/embed/lNZ9JtHjowE) para acessar.

<div style="text-align: center;">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/lNZ9JtHjowE" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</div>


## 3.3.6 Refer√™ncias Bibliogr√°ficas

> <a id="REF1">1.</a> GAMMA, Erich et al. **Padr√µes de Projeto: Solu√ß√µes Reutiliz√°veis de Software Orientado a Objetos**. Tradu√ß√£o de C. F. Lucena e F. S. C. da Silva. Porto Alegre: Bookman, 2007. (T√≠tulo original: *Design Patterns: Elements of Reusable Object-Oriented Software*).

> <a id="REF2">2.</a> SERRANO, Milene. Aula ‚Äì GOFs Comportamentais. Arquitetura e Desenho de Software. Universidade de Bras√≠lia ‚Äì UnB Gama, [s.d.]. Material de aula (apresenta√ß√£o de slides).

> <a id="REF3">3.</a> FIGUEIREDO, Roberto Ten√≥rio. Padr√µes de Projeto GOF aplicados ao Desenvolvimento de Jogos Eletr√¥nicos. 2014. 123 f. Disserta√ß√£o (Mestrado em Ci√™ncia da Computa√ß√£o) ‚Äì Universidade Federal de Pernambuco, Centro de Inform√°tica, Recife, 2014.

> <a id="REF4">4.</a> UNITY CODER CORNER. Unity: The State Pattern. Medium, 2 de ago. de 2021. Dispon√≠vel em: https://medium.com/unity-coder-corner/unity-the-state-pattern-ee067fe8bf1b. Acesso em: 24 de out. de 2025.

## Hist√≥rico de Vers√µes üìÖ

| Vers√£o | Data | Descri√ß√£o | Autor(es) | Revisor(es) |
| :--: | :--: | :--: | :--: | :--: |
| `0.1` | 24/10/2025 | Adicionando Documenta√ß√£o GoF Comportamental | [Laryssa Felix](https://github.com/felixlaryssa) | [Caio Duarte](https://github.com/caioduart3) |
| `0.2` | 24/10/2025 | Ajustes Documenta√ß√£o GoF Comportamental | [Laryssa Felix](https://github.com/felixlaryssa), [Enzo Emir]("https://github.com/EnzoEmir"), [Rafael Welz](https://github.com/RafaelSchadt) | [Caio Duarte](https://github.com/caioduart3) |
| `0.3` | 24/10/2025 | Adiciocionando Documenta√ß√£o Iterator | [Danielle Soares](https://github.com/danielle-soaress), [Leticia Arisa](https://github.com/Leticia-Arisa-K-Higa), [Maria Eduarda Andrade](https://github.com/dudaa28) | [Marcelo Makoto](https://github.com/MM4k) |
| `0.4` | 24/10/2025 | Adicionando Documenta√ß√£o GoF State | [Marcelo Makoto](https://github.com/MM4k) | [Maria Eduarda Andrade](https://github.com/dudaa28) |
